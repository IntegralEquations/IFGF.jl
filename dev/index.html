<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · IFGF.jl</title><meta name="title" content="Home · IFGF.jl"/><meta property="og:title" content="Home · IFGF.jl"/><meta property="twitter:title" content="Home · IFGF.jl"/><meta name="description" content="Documentation for IFGF.jl."/><meta property="og:description" content="Documentation for IFGF.jl."/><meta property="twitter:description" content="Documentation for IFGF.jl."/><meta property="og:url" content="https://github.com/IntegralEquations/IFGF.jl/"/><meta property="twitter:url" content="https://github.com/IntegralEquations/IFGF.jl/"/><link rel="canonical" href="https://github.com/IntegralEquations/IFGF.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>IFGF.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#introduction-section"><span>Introduction</span></a></li><li><a class="tocitem" href="#custom-kernel-section"><span>Custom kernels</span></a></li><li><a class="tocitem" href="#Advanced-usage"><span>Advanced usage</span></a></li></ul></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/IFGF.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/IFGF.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="home-section"><a class="docs-heading-anchor" href="#home-section">IFGF.jl</a><a id="home-section-1"></a><a class="docs-heading-anchor-permalink" href="#home-section" title="Permalink"></a></h1><p><em>A Julia implementation of the Interpolated Factored Green Function Method (IFGF) on adaptive trees</em></p><h2 id="introduction-section"><a class="docs-heading-anchor" href="#introduction-section">Introduction</a><a id="introduction-section-1"></a><a class="docs-heading-anchor-permalink" href="#introduction-section" title="Permalink"></a></h2><p>This package implements an algorithm for approximating the forward map (i.e. the matrix-vector product) of certain kernel matrices, where <strong>kernel matrix</strong> will be used to refer to any matrix <span>$A \in \mathbb{F}^{m\times n}$</span> whose entries can be computed from the following three components:</p><ul><li>a vector of target elements <span>$X = \left\{ \boldsymbol{x}_i \right\}_{i=1}^m$</span> </li><li>a vector of source elements <span>$Y = \left\{ \boldsymbol{y}_i \right\}_{i=1}^n$</span> </li><li>a kernel function <span>$K(x,y) : X \times Y \to \mathbb{F}$</span>, where <span>$\mathbb{F}$</span> is the return type of the kernel (and of the underlying matrix)</li></ul><p>The entries of a kernel matrix are given by the explicit formula <span>$A_{i,j} = K(\boldsymbol{x}_i,\boldsymbol{y}_j)$</span>. Typically, <span>$X$</span> and <span>$Y$</span> are vectors of points in <span>$\mathbb{R}^d$</span>, and <span>$K$</span> is a function mapping pairs of points into <span>$\mathbb{R}$</span> or <span>$\mathbb{C}$</span>.</p><p>Provided <span>$K$</span> has sufficient structure, an approximation of the product <span>$Ax$</span> can be computed in linear or log-linear complexity by various well known algorithms such as the <em>Fast Multipole Method</em> or <em>hierarchical matrices</em>; this package implements another acceleration algorithm named <em>Interpolated Factored Green Function</em> method.</p><p>To illustrate how to set up the <code>IFGFOp</code>, let <span>$X$</span> and <span>$Y$</span> be a set of random points on the unit cube, and take <span>$K$</span> to be the Helmholtz Green function in three dimensions:</p><p class="math-container">\[    K(\boldsymbol{x},\boldsymbol{y}) = \frac{e^{ik|\boldsymbol{x}-\boldsymbol{y}|}}{4\pi |\boldsymbol{x}-\boldsymbol{y}|}\]</p><p>Setting up the aforementioned kernel matrix can be done as follows:</p><pre><code class="language-julia hljs">using IFGF, LinearAlgebra, StaticArrays
import IFGF: wavenumber

# random points on a cube
const Point3D = SVector{3,Float64}
m,n = 100_000, 100_000
X,Y = rand(Point3D,m), rand(Point3D,n)

# define a the kernel matrix
struct HelmholtzMatrix &lt;: AbstractMatrix{ComplexF64}
    X::Vector{Point3D}
    Y::Vector{Point3D}
    k::Float64
end

# indicate that this is an ocillatory kernel with wavenumber `k`
wavenumber(A::HelmholtzMatrix) = A.k

# functor interface
function (K::HelmholtzMatrix)(x,y)
    k = wavenumber(K)
    d = norm(x-y)
    exp(im*k*d)*inv(4*pi*d)
end

# abstract matrix interface
Base.size(::HelmholtzMatrix) = length(X), length(Y)
Base.getindex(A::HelmholtzMatrix,i::Int,j::Int) = A(A.X[i],A.Y[j])

# create the abstract matrix
k = 8π
A = HelmholtzMatrix(X,Y,k)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100000×100000 Main.var&quot;Main&quot;.HelmholtzMatrix:
   0.0203521-0.112743im    …    0.103978-0.0276283im
 -0.00563994+0.0975022im        0.197029-0.325473im
  -0.0654339-0.43344im        -0.0114649+0.0735775im
  -0.0794073-0.090986im        0.0116536+0.0978218im
   0.0249983+0.14105im        -0.0447274+0.084562im
   -0.208756-0.0217895im   …  -0.0742672-0.0947416im
     0.14491+0.0542773im      -0.0909174+0.00888097im
   0.0420876-0.105143im         0.023862-0.080389im
   -0.127541+0.0114394im       -0.120924+0.0491545im
    0.140539+0.0629518im      -0.0908348-0.00196847im
            ⋮              ⋱  
  -0.0459889-0.0737799im        0.103107+0.0200284im
   0.0996709-0.042698im         0.126418+0.0844486im
   0.0925524+0.250107im       -0.0291091-0.113787im
  -0.0171022+0.0955816im       -0.079677+0.230957im
   -0.124028+0.0382668im   …   0.0428734-0.0710349im
   -0.116079+0.0615856im      -0.0921965-0.0795955im
   -0.145714-0.132297im        0.0277245+0.0707189im
  -0.0279143+0.0924316im        0.293455+0.0829179im
   -0.090885-0.00116943im      -0.107364+0.21518im</code></pre><p>Note that <code>A</code> is a lazy <span>$100000 \times 100000$</span> matrix which computes its entries on demand; as such, it has a light memory footprint. Trying to instantiate the underlying <code>Matrix{ComplexF64}</code> would most likely result in you running out of memory.</p><p>To build an approximation of <code>A</code> using the <code>IFGFOp</code>, you may use the high-level constructor <a href="references/#IFGF.assemble_ifgf-Tuple{Any, Any, Any}"><code>assemble_ifgf</code></a> as follows:</p><pre><code class="language-julia hljs">L = assemble_ifgf(A,X,Y; tol = 1e-4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IFGFOp of ComplexF64 with range 1:100000 × 1:100000
|-- interpolation points per cone: (4, 6, 6)
|-- maximal meshsize per cone:     (0.514, 1.57, 1.57)
|-- number of nodes:               585
|-- number of leaves:              512
|-- number of active cones:        31070
</code></pre><p>Check the documentation of <a href="references/#IFGF.assemble_ifgf-Tuple{Any, Any, Any}"><code>assemble_ifgf</code></a> for more information on the available options. One important point to keep in mind is that heuristics are used to determine the optimal number of interpolation points given a tolerance <code>tol</code>; if you want to control the number of interpolation points manually, you may pass a <code>p</code> argument to the <code>assemble_ifgf</code> constructor instead.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To approximate oscillatory kernels, the <code>IFGF</code> algorithm adapts to the acoustic size of each of the cells in the source tree in order to keep the interpolation error constant across all levels of the tree. In practice, this means that memory and runtime will depend on both the total number of points <code>n</code> and on the wavenumber <code>k</code>, with smaller <code>k</code> being &quot;easier&quot; to approximate.</p></div></div><p>We can use <code>L</code> in lieu of <code>A</code> to approximate the matrix vector product, as illustrated below:</p><pre><code class="language-julia hljs">x     = randn(ComplexF64,n)
y     = L*x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100000-element Vector{ComplexF64}:
  23.877488763730046 - 92.13418511511668im
  16.466238009420195 - 0.6750390768350938im
  -67.86383302018345 + 32.056695018870066im
  28.277978496424367 - 20.810923725417496im
 -31.622665961314286 - 8.474077821560355im
  13.939765412958074 - 81.66342784284376im
   9.610444470038589 - 13.029569104780172im
   32.70596448111352 + 34.51126198911931im
 0.34404473345908215 - 14.15189913812293im
   7.575983578077707 - 34.3371767616388im
                     ⋮
   -56.4737884822613 + 27.89452322484827im
   37.28910753149097 - 48.13785813662676im
  22.653266106275897 - 86.471445767177im
   -66.1750194395081 - 27.3797905633893im
   40.33826568373999 + 17.98247406079392im
 -17.938911975711314 + 30.20367873258438im
 -32.441987517855836 - 50.85791481476508im
    33.9847463541207 - 60.37408748870632im
  -19.57592976225946 - 58.476195698519895im</code></pre><p>Note that <code>L</code>, while not as compact as <code>A</code>, still has a relatively light memory footprint:</p><pre><code class="language-julia hljs">gb = Base.summarysize(L) / 1e9
print(&quot;Size of L: $gb gigabytes&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Size of L: 0.122107612 gigabytes</code></pre><p>The quality of the approximation may be verified by computing the exact value at a few randomly selected set of indices:</p><pre><code class="language-julia hljs">I     = rand(1:m,100)
exact = [sum(A[i,j]*x[j] for j in 1:n) for i in I] # matrix-vector product
er    = norm(y[I]-exact) / norm(exact) # relative error
print(&quot;approximate relative error: $er&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">approximate relative error: 3.0347250769068745e-5</code></pre><div class="admonition is-success"><header class="admonition-header">Kernel optimizations</header><div class="admonition-body"><p>To keep things simple in this example, we neglected some important optimizations that can be performed when defining your own kernel. In particular, you can overload some default (generic) methods for your own kernel to provide e.g. a vectorized evaluation using <code>SIMD</code> instructions. We also avoided the possible issue of kernel blowing up at <span>$\boldsymbol{x} = \boldsymbol{y}$</span>.</p></div></div><h2 id="custom-kernel-section"><a class="docs-heading-anchor" href="#custom-kernel-section">Custom kernels</a><a id="custom-kernel-section-1"></a><a class="docs-heading-anchor-permalink" href="#custom-kernel-section" title="Permalink"></a></h2><p>When defining your own kernels, there is one required as well as some optional methods to overload in order to provide kernel-specific information to the constructor. The table below summarizes the interface methods, where <code>Y</code> is a <code>SourceTree</code> object, <code>x</code> is an <code>SVector</code> representing a point, and <code>K</code> is your custom kernel:</p><table><tr><th style="text-align: right"><strong>Method&#39;s name</strong></th><th style="text-align: right"><strong>Required</strong></th><th style="text-align: right"><strong>Brief description</strong></th></tr><tr><td style="text-align: right"><a href="references/#IFGF.wavenumber"><code>wavenumber(K)</code></a></td><td style="text-align: right">Yes</td><td style="text-align: right">Return the wavenumber of your kernel</td></tr><tr><td style="text-align: right"><code>return_type(K)</code></td><td style="text-align: right">No</td><td style="text-align: right">Type of element returned by <code>K(x,y)</code></td></tr><tr><td style="text-align: right"><a href="references/#IFGF.centered_factor-Tuple{Any, Any, Any}"><code>centered_factor(K,x,Y)</code></a></td><td style="text-align: right">No</td><td style="text-align: right">A representative value of <code>K(x,y)</code> for <code>y ∈ Y</code></td></tr><tr><td style="text-align: right"><a href="references/#IFGF.inv_centered_factor-Tuple{Any, Any, Any}"><code>inv_centered_factor(K,x,Y)</code></a></td><td style="text-align: right">No</td><td style="text-align: right">A representative value of <code>inv(K(x,y))</code> for <code>y ∈ Y</code></td></tr><tr><td style="text-align: right"><a href="references/#IFGF.transfer_factor-Tuple{Any, Any, Any}"><code>transfer_factor(K,x,Y)</code></a></td><td style="text-align: right">No</td><td style="text-align: right">Transfer function given by <code>inv_centered_factor(K,x,parent(Y))*centered_factor(K,x,Y)</code></td></tr><tr><td style="text-align: right"><a href="references/#IFGF.near_interaction!-NTuple{7, Any}"><code>near_interaction!(C,K,X,Y,σ,I,J)</code></a></td><td style="text-align: right">No</td><td style="text-align: right">Compute <code>C[i] &lt;- C[i] + ∑ⱼ K(X[i],Y[j])*σ[j]</code> for <code>i ∈ I</code>, <code>j ∈ J</code></td></tr></table><p>Because the <code>IFGF</code> algorithms must adapt its interpolation scheme depending on the frequency of oscillations to control the interpolation error, you must extend the <code>IFGF.wavenumber</code> method. If the kernel is not oscillatory (e.g. exponential kernel, Newtonian potential), simply return <code>0</code>.</p><p>The <code>centered_factor</code>, <code>inv_centered_factor</code>, and <code>transfer_factor</code> have reasonable defaults, and typically are overloaded only for performance reasons (e.g. if some analytic simplifications are available).</p><p>Finally, the <code>near_interaction</code> method is called at the leaves of the source tree to compute the near interactions. Extending this function to make use of e.g. SIMD instructions can significantly speed up some parts of the code.</p><h2 id="Advanced-usage"><a class="docs-heading-anchor" href="#Advanced-usage">Advanced usage</a><a id="Advanced-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-usage" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 9 February 2024 10:49">Friday 9 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
