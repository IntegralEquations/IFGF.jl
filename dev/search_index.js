var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = IFGF","category":"page"},{"location":"#IFGF","page":"Home","title":"IFGF","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IFGF.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [IFGF]","category":"page"},{"location":"#IFGF.IFGFOp","page":"Home","title":"IFGF.IFGFOp","text":"struct IFGFOp{T} <: AbstractMatrix{T}\n\nHigh-level structure representing a linear operator with elements of type T with entry i,j given by K(X[i],Y[j]), where K is the underlying kernel function, and X and Y are the elements of the target_tree and source_tree, respectively.\n\nFields:\n\nkernel : underlying kernel function\ntarget_tree : tree structure used for clustering the target points\nsource_tree : tree structure used for clustering the source points\np::NTuple: number of chebyshev poins per dimension used in the interpolation of far interactions\nds_func : function used to compute and appropriate mesh size in parameter space. See e.g. cone_domain_size_func\n_source_tree_depth_partition : vector with i-th entry containing all nodes of the of depth i-1, where the root is given a depth of 0.\n\n\n\n\n\n","category":"type"},{"location":"#IFGF.IFGFOp-Tuple{Any, Any, Any}","page":"Home","title":"IFGF.IFGFOp","text":"IFGFOperator(kernel,Ypoints,Xpoints;splitter,p=nothing,tol=0,ds_func,threads=true)\n\nConstruct a linear operator reprensenting the action of kernel on each of Xpoints and Ypoints.\n\nArguments\n\nkernel: kernel of the IFGF operator.\nXpoints: vector of target points.\nYpoints: vector of source points.\nsplitter: splitting strategy (e.g. DyadicSplitter or CardinalitySplitter).\np: number of interpolation points per dimension in interpolation coordinates. In 3D, p = (ns,nθ,nϕ). In 2D, p = (ns,nθ).\ntol: desired relative tolerance of approximation. When tol!=0, a value of p is estimated during the construction.\nds_func: function ds_func(source_tree) = ds that returns the size of the cone domains per dimension in interpolation coordinates. In 3D, ds = (dss,dsθ,dsϕ). In 2D, ds = (dss,dsθ).\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.SourceTree","page":"Home","title":"IFGF.SourceTree","text":"const SourceTree{N,T,V}\n\nType alias for a ClusterTree of points (represented as SVector{N,T}) storing data of type SourceTreeDataLite{N,T,V}. See the documentation of ClusterTree in WavePropBase for more information.\n\n\n\n\n\n","category":"type"},{"location":"#IFGF.SourceTreeData","page":"Home","title":"IFGF.SourceTreeData","text":"mutable struct SourceTreeData{N,T,V}\n\nStruct used to store data associated with a node of the SourceTree. The parametric type N represents the ambient dimension, T represents the primitive type used to represent the points (e.g. Float32 or Float64 for single/double precision), and V is the type of the density that will be interpolated.\n\nFields:\n\nmsh: uniform cartesian mesh of the interpolation space,   indexable by a CartesianIndex\nconedatadict: dictionary mapping a cone tag I::CartesianIndex to an Array storing its interpolation values/coefficient.\nfarlist: nodes on the target tree that can be evaluated through   interpolation\nnearlist: nodes on the target tree that must be evaluated by a direct sum.\n\n\n\n\n\n","category":"type"},{"location":"#IFGF.TargetTree","page":"Home","title":"IFGF.TargetTree","text":"const TargetTree{N,T}\n\nType alias for a ClusterTree of points (represented as SVector{N,T}) containing no additional data. See the documentation of ClusterTree in WavePropBase for more information.\n\n\n\n\n\n","category":"type"},{"location":"#IFGF._addnewcone!-Union{Tuple{P}, Tuple{WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}, Any, Val{P}}} where P","page":"Home","title":"IFGF._addnewcone!","text":"_addnewcone!(node::SourceTree,I::CartesianIndex,p)\n\nIf node does not contain cone I, add it to the conedict.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF._density_type_from_kernel_type-Tuple{Any}","page":"Home","title":"IFGF._density_type_from_kernel_type","text":"_density_type_from_kernel_type(T)\n\nHelper function to compute the expected density V type associated with a kernel type T. For T<:Number, simply return T. For T<:SMatrix, return an SVector with elements of the type eltype(T) and of length size(T,2) so that multiplying an element of type T with an element of type V makes sense.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF._init_msh!-Tuple{WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}, Any, Any}","page":"Home","title":"IFGF._init_msh!","text":"_init_msh!(node,domain,ds)\n\nCreate a uniform cartesian mesh of the interpolation domain of node with element spacing ds.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.allocate_interpolant_data!-Union{Tuple{P}, Tuple{WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}, Val{P}, Any}} where P","page":"Home","title":"IFGF.allocate_interpolant_data!","text":"allocate_interpolant_data!(node::SourceTree,::Val{P},[I])\n\nAllocate the memory necessary to construct the I cone interpolant of node with P points, where P is a tuple of integers. If I is absent, allocate data for all cone interpolants of node.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.cart2interp-Tuple{Any, WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}}","page":"Home","title":"IFGF.cart2interp","text":"cart2interp(x,c,h)\ncart2interp(x,source::SourceTree)\n\nMap cartesian coordinates x into interpolation coordinates s centered at c and scaled by h. Interpolation coordinates are similar to hyperspherical coordinates (e.g. polar in two-dimensions and spherical in three-dimensions), except that the radial coordinates is replaced by s=h/r.\n\nIf passed a SourceTree, use its center and radius as c and h respectively.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.centered_factor-Tuple{Any, Any, WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}}","page":"Home","title":"IFGF.centered_factor","text":"centered_factor(K,x,Y::SourceTree)\n\nScalar function used to help the interpolation of I(x) = ∑ᵢ K(x,yᵢ) where yᵢ ∈ Y and points x in the far field of Y. Defaults to K(x,yc) where yc is the center of Y.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.cheb2nodes-Tuple{Any}","page":"Home","title":"IFGF.cheb2nodes","text":"cheb2nodes(n,[domain])\ncheb2nodes(p::NTuple,[domain])\ncheb2nodes(::Val{P},[domain])\n\nReturn the n Chebyshev nodes of the second kind on the interval [-1,1].\n\nIf passed a tuple p, return the tensor product of one-dimensinal nodes of size p.\n\nIf passed a Val{P}, statically compute the tensor product nodes.\n\nFinally, passing a domain::HyperRectangle shifts the interpolation nodes to it.\n\nlb = (0.,0.)\nub = (3.,2.)\ndomain = HyperRectangle(lb,ub)\ncheb2nodes((10,5),domain) # generate `10×5` Chebyshev nodes on the `[0,3]×[0,2]` rectangle.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.cheb_error_estimate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}","page":"Home","title":"IFGF.cheb_error_estimate","text":"cheb_error_estimate(coefs::AbstractArray{T,N},dim)\n\nGiven an N dimensional array of coeffients , estimate the relative error commited by the Chebyshev interpolant along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.compute_cone_list!-Tuple{IFGFOp, Any}","page":"Home","title":"IFGF.compute_cone_list!","text":"compute_cone_list!(ifgf::IFGFOperator)\n\nFor each node in source_tree(ifgf), compute the cones which are necessary to cover both the target points on its farlist as well as the interpolation points on its parent's cones. The polynomial_order(ifgf) and meshsize_func(ifgf) are used to construct the appropriate interpolation domains and points.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.compute_interaction_list!-Tuple{IFGFOp, Any}","page":"Home","title":"IFGF.compute_interaction_list!","text":"compute_interaction_list!(ifgf::IFGFOperator,adm)\n\nFor each node in source_tree(ifgf), compute its nearlist and farlist. The nearlist contains all nodes in target_tree(ifgf) for which the interaction must be computed using the direct summation.  The farlist includes all nodes in target_tree for which an accurate interpolant in available in the source node.\n\nThe adm function is called through adm(target,source) to determine if target is in the farlist of source. When that is not the case we recurse on their children unless both are a leaves, in which case target is added to the nearlist of source.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.compute_interpolation_domain-Union{Tuple{P}, Tuple{Td}, Tuple{N}, Tuple{WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, Td}, 1}, WavePropBase.Interpolation.HyperRectangle{N, Td}, IFGF.SourceTreeData{N, Td, V}} where V, Val{P}}} where {N, Td, P}","page":"Home","title":"IFGF.compute_interpolation_domain","text":"compute_interpolation_domain(source::SourceTree)\n\nCompute the minimal domain (as a HyperRectangle) in interpolation space for which source must provide a covering through its cone interpolants.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.cone_domain_size_func","page":"Home","title":"IFGF.cone_domain_size_func","text":"cone_domain_size_func(Δs₀::NTuple{N,T},k)\n\nReturns an anonymous function (node) -> Δs that computes an appropriate size Δs for the interpolation domain of node given an intial size Δs₀ and a wavenumber k. The function is constructed so as to scale Δs₀ by the inverse of the acoustic size of node.\n\n\n\n\n\n","category":"function"},{"location":"#IFGF.cone_index-Tuple{StaticArrays.SVector, WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}}","page":"Home","title":"IFGF.cone_index","text":"cone_index(x::SVector,tree::SourceTree)\n\nGiven a point x in cartesian coordinates, return the index I of the cone in source to whcih x belongs, as well as its parametric coordinate s.\n\nSee also: cart2interp\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.element_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, WavePropBase.Mesh.UniformCartesianMesh{N}}} where N","page":"Home","title":"IFGF.element_index","text":"element_index(s::SVector,m::UniformCartesianMesh)\n\nGiven a point s ∈ m, return the index I of the element in m containing s.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.free_interpolant_data!-Tuple{WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}, CartesianIndex}","page":"Home","title":"IFGF.free_interpolant_data!","text":"free_interpolant_data!(node,[I])\n\nFree the memory used to store the I cone interpolant of node. If I is absent, free data associated to all cone interpolants of node\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.initialize_source_tree-Union{Tuple{}, Tuple{T}, Tuple{N}} where {N, T}","page":"Home","title":"IFGF.initialize_source_tree","text":"initialize_source_tree(;points,datatype,splitter,Xdatatype)\n\nCreate the tree-structure for clustering the source points using the splitting strategy of splitter, returning a SourceTree built through the empty constructor (i.e. data = SourceTreeData()).\n\nArguments\n\npoints: vector of source points.\nsplitter: splitting strategy.\nXdatatype: type container of target points.\nVdatatype: type of value stored at interpolation nodes\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.initialize_target_tree-Tuple{}","page":"Home","title":"IFGF.initialize_target_tree","text":"initialize_target_tree(;points,splitter)\n\nCreate the tree-structure for clustering the target points using the splitting strategy of splitter. Returns a TargetTree.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.interp2cart-Tuple{Any, WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}}","page":"Home","title":"IFGF.interp2cart","text":"interp2cart(s,xc,h)\ninterp2cart(s,source::SourceTree)\n\nMap interpolation coordinate s into the corresponding cartesian coordinates.\n\nInterpolation coordinates are similar to polar (in 2d) or spherical (in 3d) coordinates centered at the xc, except that the radial coordinate r is replaced by s = h/r.\n\nIf passed a SourceTree as second argument, call interp2cart(s,xc,h) with xc the center of the SourceTree and h its radius.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.modified_admissibility_condition-Tuple{Any, Any, Any}","page":"Home","title":"IFGF.modified_admissibility_condition","text":"modified_admissible_condition(target,source,[η])\n\nA target and source are admissible under the modified admissiblility condition (MAC) if the target box lies farther than r*η away, where r is the radius of the source box and η >= 1 is an adjustable parameter. By default, η = N / √N, where N is the ambient dimension.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.near_interaction!-NTuple{7, Any}","page":"Home","title":"IFGF.near_interaction!","text":"near_interaction!(C,K,X,Y,σ,I,J)\n\nCompute C[i] <-- C[i] + ∑ⱼ K(X[i],Y[j])*σ[j] for i ∈ I, j ∈ J. The default implementation simply does a double loop over all i ∈ I and j ∈ J, but you override this method for the type of your own custom kernel K if you have a fast way of computing the full product in-place (e.g. using SIMD instructions).\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.transfer_factor-Tuple{Any, Any, WavePropBase.Trees.ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.Interpolation.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T, V}} where {N, T, V}}","page":"Home","title":"IFGF.transfer_factor","text":"transfer_factor(K,x,Y::SourceTree)\n\nRatio between the centered factor of Y and the centered factor of its parent.\n\n\n\n\n\n","category":"method"},{"location":"#IFGF.@hprofile-Tuple{Any}","page":"Home","title":"IFGF.@hprofile","text":"@hprofile\n\nA macro which\n\nresets the default TimerOutputs.get_defaulttimer to zero\nexecute the code block\nprint the profiling details\n\nThis is useful as a coarse-grained profiling strategy to get a rough idea of where time is spent. Note that this relies on TimerOutputs annotations manually inserted in the code.\n\n\n\n\n\n","category":"macro"}]
}
