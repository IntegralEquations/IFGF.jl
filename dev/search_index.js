var documenterSearchIndex = {"docs":
[{"location":"references/#references-section","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Modules = [IFGF]","category":"page"},{"location":"references/#IFGF.IFGFOp","page":"References","title":"IFGF.IFGFOp","text":"struct IFGFOp{T} <: AbstractMatrix{T}\n\nHigh-level structure representing a linear operator with elements of type T with entry i,j given by K(X[i],Y[j]), where K is the underlying kernel function, and X and Y are the elements of the target_tree and source_tree, respectively.\n\nFields:\n\nkernel : underlying kernel function\ntarget_tree : tree structure used for clustering the target points\nsource_tree : tree structure used for clustering the source points\np::NTuple: number of chebyshev poins per dimension used in the interpolation of far interactions\nds_func : function used to compute and appropriate mesh size in parameter space. See e.g. cone_domain_size_func\nadm_func : function used to determine if the block with targets on box A and sources on box B admit a low-rank approximation\n_source_tree_depth_partition : vector with i-th entry containing all nodes of the of depth i-1, where the root is given a depth of 0.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.SourceTree","page":"References","title":"IFGF.SourceTree","text":"const SourceTree{N,T,V}\n\nType alias for a ClusterTree of points (represented as SVector{N,T}) storing data of type SourceTreeData{N,T,V}. See the documentation of ClusterTree for more details.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.SourceTreeData","page":"References","title":"IFGF.SourceTreeData","text":"mutable struct SourceTreeData{N,T,V}\n\nStruct used to store data associated with a node of the SourceTree. The parametric type N represents the ambient dimension, T represents the primitive type used to represent the points (e.g. Float32 or Float64 for single/double precision), and V is the type of the density that will be interpolated.\n\nFields:\n\nmsh: uniform cartesian mesh of the interpolation space,   indexable by a CartesianIndex\nconedatadict: dictionary mapping a cone tag I::CartesianIndex to an Array storing its interpolation values/coefficient.\nfarlist: nodes on the target tree that can be evaluated through   interpolation\nnearlist: nodes on the target tree that must be evaluated by a direct sum.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.TargetTree","page":"References","title":"IFGF.TargetTree","text":"const TargetTree{N,T}\n\nType alias for a ClusterTree of points (represented as SVector{N,T}) containing no additional data. See the documentation of ClusterTree in WavePropBase for more information.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF._addnewcone!-Union{Tuple{P}, Tuple{ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T}} where {N, T}, Any, Val{P}}} where P","page":"References","title":"IFGF._addnewcone!","text":"_addnewcone!(node::SourceTree,I::CartesianIndex,p)\n\nIf node does not contain cone I, add it to the conedict.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._density_type_from_kernel_type-Tuple{Any}","page":"References","title":"IFGF._density_type_from_kernel_type","text":"_density_type_from_kernel_type(T)\n\nHelper function to compute the expected density V type associated with a kernel type T. For T<:Number, simply return T. For T<:SMatrix, return an SVector with elements of the type eltype(T) and of length size(T,2) so that multiplying an element of type T with an element of type V makes sense.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._init_msh!-Tuple{ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T}} where {N, T}, Any, Any}","page":"References","title":"IFGF._init_msh!","text":"_init_msh!(node,domain,ds)\n\nCreate a uniform cartesian mesh of the interpolation domain of node with element spacing ds.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.assemble_ifgf-Tuple{Any, Any, Any}","page":"References","title":"IFGF.assemble_ifgf","text":"assemble_ifgf(K,X,Y;nmax=100,adm=modified_admissibility_condition,order=nothing,tol=1e-4,Δs=1.0,threads=true)\n\nConstruct an approximation of the matrix [K(x,y) for x ∈ X, y ∈ Y]. If the kernel function K is oscillatory, you should implement the method wavenumber(::typeof(K)) --> Number to return its wavenumber.\n\nThe error in the approximation is controlled by two parameters: Δs and order. These parameters dictate the mesh size and interpolation order of the parametric space used to build the cone interpolants. While the order is held constant across all source cells, the Δs parameter controls only the size of the low-frequency cells; for cells of large acoustic size, the mesh size is adapted so as to keep the interpolation error constant across different levels of the source tree (see cone_domain_size_func for implementation details).\n\nIf the keyword order is ommited, a tolerance tol must be passed. It will then be used to estimate an appropriate interpolation order.\n\nnmax can be used to control the maximum number of points contained in the target/source trees.\n\nThe adm function gives a criterion to determine if the interaction between a target cell and a source cell should be computed using an interpolation scheme.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.cart2interp-Tuple{Any, ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T}} where {N, T}}","page":"References","title":"IFGF.cart2interp","text":"cart2interp(x,c,h)\ncart2interp(x,source::SourceTree)\n\nMap cartesian coordinates x into interpolation coordinates s centered at c and scaled by h. Interpolation coordinates are similar to hyperspherical coordinates (e.g. polar in two-dimensions and spherical in three-dimensions), except that the radial coordinates is replaced by s=h/r.\n\nIf passed a SourceTree, use its center and radius as c and h respectively.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.centered_factor-Tuple{Any, Any, Any}","page":"References","title":"IFGF.centered_factor","text":"centered_factor(K,x,Y::SourceTree)\n\nReturn a representative value of K(x,y) for y ∈ Y. This is used to help the interpolation of I(x) = ∑ᵢ K(x,yᵢ) where yᵢ ∈ Y and points x in the far field of Y. Defaults to K(x,yc) where yc is the center of Y.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.cheb2nodes-Tuple{Any}","page":"References","title":"IFGF.cheb2nodes","text":"cheb2nodes(n,[domain])\ncheb2nodes(p::NTuple,[domain])\ncheb2nodes(::Val{P},[domain])\n\nReturn the n Chebyshev nodes of the second kind on the interval [-1,1].\n\nIf passed a tuple p, return the tensor product of one-dimensinal nodes of size p.\n\nIf passed a Val{P}, statically compute the tensor product nodes.\n\nFinally, passing a domain::HyperRectangle shifts the interpolation nodes to it.\n\nlb = (0.,0.)\nub = (3.,2.)\ndomain = HyperRectangle(lb,ub)\ncheb2nodes((10,5),domain) # generate `10×5` Chebyshev nodes on the `[0,3]×[0,2]` rectangle.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.cheb_error_estimate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}","page":"References","title":"IFGF.cheb_error_estimate","text":"cheb_error_estimate(coefs::AbstractArray{T,N},dim)\n\nGiven an N dimensional array of coefficients , estimate the relative error commited by the Chebyshev interpolant along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.compute_cone_list!-Tuple{IFGFOp, Any}","page":"References","title":"IFGF.compute_cone_list!","text":"compute_cone_list!(ifgf::IFGFOperator)\n\nFor each node in source_tree(ifgf), compute the cones which are necessary to cover both the target points on its farlist as well as the interpolation points on its parent's cones. The polynomial_order(ifgf) and meshsize_func(ifgf) are used to construct the appropriate interpolation domains and points.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.compute_interaction_list!","page":"References","title":"IFGF.compute_interaction_list!","text":"compute_interaction_list!(ifgf::IFGFOperator,adm)\n\nFor each node in source_tree(ifgf), compute its nearlist and farlist. The nearlist contains all nodes in target_tree(ifgf) for which the interaction must be computed using the direct summation.  The farlist includes all nodes in target_tree for which an accurate interpolant in available in the source node.\n\nThe adm function is called through adm(target,source) to determine if target is in the farlist of source. When that is not the case we recurse on their children unless both are a leaves, in which case target is added to the nearlist of source.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.compute_interpolation_domain-Union{Tuple{P}, Tuple{Td}, Tuple{N}, Tuple{ClusterTree{Array{StaticArrays.SVector{N, Td}, 1}, WavePropBase.HyperRectangle{N, Td}, IFGF.SourceTreeData{N, Td}}, Val{P}}} where {N, Td, P}","page":"References","title":"IFGF.compute_interpolation_domain","text":"compute_interpolation_domain(source::SourceTree)\n\nCompute the minimal domain (as a HyperRectangle) in interpolation space for which source must provide a covering through its cone interpolants.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.cone_domain_size_func-Tuple{Any, Any}","page":"References","title":"IFGF.cone_domain_size_func","text":"cone_domain_size_func(Δs₀::NTuple{N,T},k)\n\nReturns an anonymous function (node) -> Δs that computes an appropriate size Δs for the interpolation domain of node given an intial size Δs₀ and a wavenumber k. The function is constructed so as to scale Δs₀ by the inverse of the acoustic size of node.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.cone_index-Tuple{StaticArrays.SVector, ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T}} where {N, T}}","page":"References","title":"IFGF.cone_index","text":"cone_index(x::SVector,tree::SourceTree)\n\nGiven a point x in cartesian coordinates, return the index I of the cone in source to whcih x belongs, as well as its parametric coordinate s.\n\nSee also: cart2interp\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.element_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, WavePropBase.UniformCartesianMesh{N}}} where N","page":"References","title":"IFGF.element_index","text":"element_index(s::SVector,m::UniformCartesianMesh)\n\nGiven a point s ∈ m, return the index I of the element in m containing s.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.initialize_source_tree-Union{Tuple{}, Tuple{T}, Tuple{N}} where {N, T}","page":"References","title":"IFGF.initialize_source_tree","text":"initialize_source_tree(;points,datatype,splitter,Xdatatype)\n\nCreate the tree-structure for clustering the source points using the splitting strategy of splitter, returning a SourceTree built through the empty constructor (i.e. data = SourceTreeData()).\n\nArguments\n\npoints: vector of source points.\nsplitter: splitting strategy.\nXdatatype: type container of target points.\nVdatatype: type of value stored at interpolation nodes\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.initialize_target_tree-Tuple{}","page":"References","title":"IFGF.initialize_target_tree","text":"initialize_target_tree(;points,splitter)\n\nCreate the tree-structure for clustering the target points using the splitting strategy of splitter. Returns a TargetTree.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.interp2cart-Tuple{Any, ClusterTree{Array{StaticArrays.SVector{N, T}, 1}, WavePropBase.HyperRectangle{N, T}, IFGF.SourceTreeData{N, T}} where {N, T}}","page":"References","title":"IFGF.interp2cart","text":"interp2cart(s,xc,h)\ninterp2cart(s,source::SourceTree)\n\nMap interpolation coordinate s into the corresponding cartesian coordinates.\n\nInterpolation coordinates are similar to polar (in 2d) or spherical (in 3d) coordinates centered at the xc, except that the radial coordinate r is replaced by s = h/r.\n\nIf passed a SourceTree as second argument, call interp2cart(s,xc,h) with xc the center of the SourceTree and h its radius.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.inv_centered_factor-Tuple{Any, Any, Any}","page":"References","title":"IFGF.inv_centered_factor","text":"inv_centered_factor(K,x,Y)\n\nInverse of centered_factor.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.modified_admissibility_condition-Tuple{Any, Any, Any}","page":"References","title":"IFGF.modified_admissibility_condition","text":"modified_admissible_condition(target,source,[η])\n\nA target and source are admissible under the modified admissiblility condition (MAC) if the target box lies farther than r*η away, where r is the radius of the source box and η >= 1 is an adjustable parameter. By default, η = N / √N, where N is the ambient dimension.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.near_interaction!-NTuple{7, Any}","page":"References","title":"IFGF.near_interaction!","text":"near_interaction!(C,K,X,Y,σ,I,J)\n\nCompute C[i] <-- C[i] + ∑ⱼ K(X[i],Y[j])*σ[j] for i ∈ I, j ∈ J. The default implementation simply does a double loop over all i ∈ I and j ∈ J, but you override this method for the type of your own custom kernel K if you have a fast way of computing the full product in-place (e.g. using SIMD instructions).\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.transfer_factor-Tuple{Any, Any, Any}","page":"References","title":"IFGF.transfer_factor","text":"transfer_factor(K,x,Y::SourceTree)\n\nRatio between the centered factor of Y and the centered factor of its parent.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.wavenumber","page":"References","title":"IFGF.wavenumber","text":"wavenumber(K::Function)\n\nFor oscillatory kernels, return the characteristic wavenumber (i.e 2π divided by he wavelength). For non-oscillatory kernels, return 0.\n\n\n\n\n\n","category":"function"},{"location":"references/#LinearAlgebra.mul!-Tuple{AbstractVector, IFGFOp, AbstractVector, Number, Number}","page":"References","title":"LinearAlgebra.mul!","text":"mul!(y,A::IFGFOp,x,a,b;global_index=true,threads=true)\n\nLike the mul! function from LinearAlgebra. Setting global_index=false uses the internal indexing system of the IFGFOp, and therefore does not permute the vectors x and y to perform the multiplication.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.@hprofile-Tuple{Any}","page":"References","title":"IFGF.@hprofile","text":"@hprofile\n\nA macro which\n\nresets the default TimerOutputs.get_defaulttimer to zero\nexecute the code block\nprint the profiling details\n\nThis is useful as a coarse-grained profiling strategy to get a rough idea of where time is spent. Note that this relies on TimerOutputs annotations manually inserted in the code.\n\n\n\n\n\n","category":"macro"},{"location":"references/","page":"References","title":"References","text":"WavePropBase.ClusterTree","category":"page"},{"location":"references/#WavePropBase.ClusterTree","page":"References","title":"WavePropBase.ClusterTree","text":"mutable struct ClusterTree{T,S,D}\n\nTree structure used to cluster elements of type V = eltype(T) into containers of type S. The method center(::V)::SVector is required for the clustering algorithms. An additional data field of type D can be associated with each node to store node-specific information (it defaults to D=Nothing).\n\nFields:\n\n_elements::T : vector containing the sorted elements.\ncontainer::S : container for the elements in the current node.\nindex_range::UnitRange{Int} : indices of elements contained in the current node.\nloc2glob::Vector{Int} : permutation from the local indexing system to the original (global) indexing system used as input in the construction of the tree.\nchildren::Vector{ClusterTree{N,T,D}}\nparent::ClusterTree{N,T,D}\ndata::D : generic data field of type D.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = IFGF","category":"page"},{"location":"#home-section","page":"Home","title":"IFGF.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A pure Julia implementation of the Interpolated Factored Green Function Method on adaptive trees","category":"page"},{"location":"#introduction-section","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements an algorithm for approximating the forward map (i.e. the matrix-vector product) of certain kernel matrices, where kernel matrix will be used to refer to any matrix A in mathbbF^mtimes n whose entries can be computed from the following three components: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"a vector of target elements X = left boldsymbolx_i right_i=1^m \na vector of source elements Y = left boldsymboly_i right_i=1^n \na kernel function K(xy)  X times Y to mathbbF, where mathbbF is the return type of the kernel (and of the underlying matrix)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The entries of a kernel matrix are given by the explicit formula A_ij = K(boldsymbolx_iboldsymboly_j). Typically, X and Y are vectors of points in mathbbR^d, and K is a function mapping pairs of points into mathbbR or mathbbC. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provided K has sufficient structure, an approximation of the product Ax can be computed in linear or log-linear complexity by various well known algorithms such as the Fast Multipole Method or hierarchical matrices; this package implements another acceleration algorithm named Interpolated Factored Green Function method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main structure exported by this package is the IFGFOp{T}, which inherits from AbstractMatrix{T} and supports some basic linear algebra operations. To construct an IFGFOp you will need to specify a kernel K, the target elements X, and the source elements Y. You may also need to pass some problem-specific information regarding K. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To illustrate how to set up the IFGFOp, let X and Y be a set of random points on the unit cube, and take K to be the Helmholtz Green function in three dimensions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    K(boldsymbolxboldsymboly) = frace^ikboldsymbolx-boldsymboly4pi boldsymbolx-boldsymboly","category":"page"},{"location":"","page":"Home","title":"Home","text":"Setting up the aforementioned kernel matrix can be done as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nusing IFGF, LinearAlgebra, StaticArrays\nimport IFGF: wavenumber\n\n# random points on a cube\nconst Point3D = SVector{3,Float64}\nm,n = 100_000, 100_000\nX,Y = rand(Point3D,m), rand(Point3D,n)\n\n# define a the kernel matrix\nstruct HelmholtzMatrix <: AbstractMatrix{ComplexF64}\n    X::Vector{Point3D}\n    Y::Vector{Point3D}\n    k::Float64\nend\n\n# indicate that this is an ocillatory kernel with wavenumber `k`\nwavenumber(A::HelmholtzMatrix) = A.k\n\n# functor interface\nfunction (K::HelmholtzMatrix)(x,y)\n    k = wavenumber(K)\n    d = norm(x-y)\n    exp(im*k*d)*inv(4*pi*d)\nend\n\n# abstract matrix interface\nBase.size(A::HelmholtzMatrix) = length(X), length(Y)\nBase.getindex(A::HelmholtzMatrix,i::Int,j::Int) = A(A.X[i],A.Y[j])\n\n# create the abstract matrix\nk = 8π   \nA = HelmholtzMatrix(X,Y,k)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that A is a lazy 100000 times 100000 matrix which computes its entries on demand; as such, it has a light memory footprint. Trying to instantiate the underlying Matrix{ComplexF64} would most likely result in you running out of memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To build an approximation of A using the IFGFOp, you may use the high-level constructor assemble_ifgf as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"L = assemble_ifgf(A,X,Y;tol=1e-3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check the documentation of assemble_ifgf for more information on the available options. Note that L, while not as compact as A, still has a relatively light memory footprint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"gb = Base.summarysize(L) / 1e9\nprint(\"Size of L: $gb gigabytes\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Info\nTo approximate oscillatory kernels, the IFGF algorithm adapts to the acoustic size of each of the cells in the source tree in order to keep the interpolation error constant across all levels of the tree. In practice, this means that memory and runtime will depend on both the total number of points n and on the wavenumber k, with smaller k being \"easier\" to approximate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can use L in lieu of A to approximate the matrix vector product, as illustrated below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x     = randn(ComplexF64,n)\ny     = L*x","category":"page"},{"location":"","page":"Home","title":"Home","text":"The quality of the approximation may be verified by computing the exact value at a few randomly selected set of indices:","category":"page"},{"location":"","page":"Home","title":"Home","text":"I     = rand(1:m,100)\nexact = [sum(A[i,j]*x[j] for j in 1:n) for i in I] # matrix-vector product\ner    = norm(y[I]-exact) / norm(exact) # relative error\nprint(\"approximate relative error: $er\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Kernel optimizations\nTo keep things simple in this example, we neglected some important optimizations that can be performed when defining your own kernel. In particular, you can overload some default (generic) methods for your own kernel to provide e.g. a vectorized evaluation using SIMD instructions. We also avoided the possible issue of kernel blowing up at boldsymbolx = boldsymboly. See the the test/testutils.jl file for an optimized definition of some classical kernels, or the Custom kernels section for a discussion on what methods can be overloaded.","category":"page"},{"location":"#custom-kernel-section","page":"Home","title":"Custom kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When defining your own kernel matrix, there is one required as well as some optional methods to overload in order to provide kernel-specific information to the IFGFOp constructor. The table below summarizes the interface methods, where Y is a SourceTree, x is an SVector representing a point, and K is your custom kernel:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method's name Required Brief description\nwavenumber(K) Yes Return the wavenumber of your kernel\nreturn_type(K) No Type of element returned by K(x,y)\ncentered_factor(K,x,Y) No A representative value of K(x,y) for y ∈ Y\ninv_centered_factor(K,x,Y) No A representative value of inv(K(x,y)) for y ∈ Y\ntransfer_factor(K,x,Y) No Transfer function given by inv_centered_factor(K,x,parent(Y))*centered_factor(K,x,Y)\nnear_interaction!(C,K,X,Y,σ,I,J) No Compute C[i] <- C[i] + ∑ⱼ K(X[i],Y[j])*σ[j] for i ∈ I, j ∈ J","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because the IFGF algorithms must adapt its interpolation scheme depending on the frequency of oscillations to control the interpolation error, you must extend the IFGF.wavenumber method. If the kernel is not oscillatory (e.g. exponential kernel, Newtonian potential), simply return 0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The return_type method will be used to infer the type of the underlying abstract matrix. By default, it will use Base.promote_op to try and infer a return type, but you may force that type manually if needed by extending this method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The centered_factor, inv_centered_factor, and transfer_factor have reasonable defaults, and typically are overloaded only for performance reasons (e.g. if some analytic simplifications are available).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the near_interaction method is called at the leaves of the source tree to compute, well, the near interactions. Extending this function to make use of e.g. SIMD instructions can significantly speed up some parts of the code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To illustrate how to define a new kernel with the aforementioned hooks, we will first extend the definition of the HelmholtzMatrix (done in the introduction) by implementing a vectorized near_interaction method using the LoopVectorization package. The code below, though more complex, implements a vectorized evaluation of the dense forward map:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LoopVectorization\n\nfunction IFGF.near_interaction!(C,K::HelmholtzMatrix,X,Y,σ,I,J)\n    Tx = eltype(X)\n    Ty = eltype(Y)\n    @assert Tx <: SVector && Ty <: SVector\n    Xm = reshape(reinterpret(eltype(Tx),X),3,:)\n    Ym = reshape(reinterpret(eltype(Ty),Y),3,:)\n    @views helmholtz3d_sl_vec!(C[I],Xm[:,I],Ym[:,J],σ[J],K.k)\nend\n\nfunction helmholtz3d_sl_vec!(C::AbstractVector{Complex{T}},X,Y,σ,k) where {T}\n    @assert eltype(σ) == eltype(C)\n    m,n = size(X,2), size(Y,2)\n    C_T = reinterpret(T, C)\n    C_r = @views C_T[1:2:end,:]\n    C_i = @views C_T[2:2:end,:]\n    σ_T = reinterpret(T, σ)\n    σ_r = @views σ_T[1:2:end,:]\n    σ_i = @views σ_T[2:2:end,:]\n    @turbo for j in 1:n # LoopVectorization magic\n        for i in 1:m\n            d2 = (X[1,i] - Y[1,j])^2\n            d2 += (X[2,i] - Y[2,j])^2\n            d2 += (X[3,i] - Y[3,j])^2\n            d  = sqrt(d2)\n            s, c = sincos(k * d)\n            zr = inv(4π*d) * c\n            zi = inv(4π*d) * s\n            C_r[i] += (!iszero(d))*(zr*σ_r[j] - zi*σ_i[j])\n            C_i[i] += (!iszero(d))*(zi*σ_r[j] + zr*σ_i[j])\n        end\n    end\n    return C\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"The other optimization that we can perform for the HelmhotlzMatrix is to rewrite the transfer_factor so that it uses only one exponential. The default definition of transfer_factor(K,x,Y) simply divides K(x,yc) by K(x,yp), where yc is the center of the source box Y and yp is the center of the parent of Y. This division can be simplified to avoid computing two complex exponentials as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function IFGF.transfer_factor(K::HelmholtzMatrix,x,Y)\n    yc  = IFGF.center(Y)\n    yp  = IFGF.center(IFGF.parent(Y))\n    d   = norm(x-yc)\n    dp  = norm(x-yp)\n    exp(im*K.k*(d-dp))*dp/d\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can check that the result is still correct with the code below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"y     = L*x\ner    = norm(y[I]-exact) / norm(exact) # relative error\nprint(\"approximate relative error: $er\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, you should benchmark your code (with your specific kernel) to see if and when it may be useful to provide faster versions of these methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Tensor-valued kernels\nEverything said so far applies if K returns a tensor instead of a scalar. This is the case e.g. for the dyadic Green function for time-harmonic Maxwell's equations, given by    K(boldsymbolxboldsymboly) = mathbbG(boldsymbolx boldsymboly) = left(mathbbI+fracnabla_boldsymbolx nabla_boldsymbolxk^2right) G(boldsymbolx boldsymboly)where k is a constant which depends on the electric permittivity, the magnetic permeability, and the angular frequency, and whereG(boldsymbolxboldsymboly) = frace^ikboldsymbolx-boldsymboly4pi boldsymbolx-boldsymbolyis the Helmholtz Green's function.Defining for example a MaxwellKernel as done below, and calling the assemble_ifgf constructor, should work as expected. Note that, for performance reasons, tensor-valued kernels will typically return a StaticArray.\nusing IFGF, StaticArrays, LinearAlgebra\n\nstruct MaxwellKernel\n    k::Float64\nend\n\nfunction (K::MaxwellKernel)(x,y)\n    r   = x - y\n    d   = norm(r)\n    # helmholtz greens function\n    g   = exp(im*K.k*d)/(4π*d)\n    gp  = im*K.k*g - g/d\n    gpp = im*K.k*gp - gp/d + g/d^2\n    RRT = r*transpose(r) # rvec ⊗ rvecᵗ\n    G   = g*LinearAlgebra.I + 1/K.k^2*(gp/d*LinearAlgebra.I + (gpp/d^2 - gp/d^3)*RRT)\n    return (!iszero(d))*G\nend\nimport IFGF: wavenumber\nwavenumber(K::MaxwellKernel) = K.k","category":"page"},{"location":"#Advanced-usage","page":"Home","title":"Advanced usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The assemble_ifgf provides a high-level constructor for the IFGFOp structure by making various default choices of clustering algorithms, admisibility condition, how the interpolation cones should be created, etc. To obtain a more granular control over these parameters, you have to create them independently and pass them to the (default) IFGF constructor","category":"page"},{"location":"","page":"Home","title":"Home","text":"Resuming the example for the Helmholtz kernel, we will go over all the steps to manually construct the fields of the IFGFOp.","category":"page"},{"location":"#Target-tree","page":"Home","title":"Target tree","text":"","category":"section"},{"location":"#Source-tree","page":"Home","title":"Source tree","text":"","category":"section"},{"location":"#Interaction-list","page":"Home","title":"Interaction list","text":"","category":"section"},{"location":"#Cone-domains","page":"Home","title":"Cone domains","text":"","category":"section"},{"location":"#IFGFOp","page":"Home","title":"IFGFOp","text":"","category":"section"}]
}
