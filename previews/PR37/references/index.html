<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References · IFGF.jl</title><meta name="title" content="References · IFGF.jl"/><meta property="og:title" content="References · IFGF.jl"/><meta property="twitter:title" content="References · IFGF.jl"/><meta name="description" content="Documentation for IFGF.jl."/><meta property="og:description" content="Documentation for IFGF.jl."/><meta property="twitter:description" content="Documentation for IFGF.jl."/><meta property="og:url" content="https://github.com/IntegralEquations/IFGF.jl/references/"/><meta property="twitter:url" content="https://github.com/IntegralEquations/IFGF.jl/references/"/><link rel="canonical" href="https://github.com/IntegralEquations/IFGF.jl/references/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">IFGF.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/IFGF.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/IFGF.jl/blob/main/docs/src/references.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="references-section"><a class="docs-heading-anchor" href="#references-section">References</a><a id="references-section-1"></a><a class="docs-heading-anchor-permalink" href="#references-section" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.AbstractPDE" href="#IFGF.AbstractPDE"><code>IFGF.AbstractPDE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPDE{N}</code></pre><p>A partial differential equation in dimension <code>N</code>. <code>AbstractPDE</code> types are used to define <code>AbstractPDEKernel</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/kernels.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.AbstractSplitter" href="#IFGF.AbstractSplitter"><code>IFGF.AbstractSplitter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSplitter</code></pre><p>An <code>AbstractSplitter</code> is used to split a <a href="#IFGF.ClusterTree"><code>ClusterTree</code></a>. The interface requires the following methods:</p><ul><li><code>should_split(clt,splitter)</code> : return a <code>Bool</code> determining if the <code>ClusterTree</code> should be further divided</li><li><code>split!(clt,splitter)</code> : perform the splitting of the <code>ClusterTree</code> handling the necessary data sorting.</li></ul><p>See <a href="#IFGF.DyadicSplitter"><code>DyadicSplitter</code></a> for an example of an implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/splitter.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.AdmissibilityCondition" href="#IFGF.AdmissibilityCondition"><code>IFGF.AdmissibilityCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AdmissibilityCondition</code></pre><p>Functor used to determine if the interaction between a <code>target</code> and a <code>source</code> can be approximated using an interpolation scheme.</p><p>A target and source are admissible under this <em>admissiblility condition</em> if the target box lies farther than <code>r*η</code> away, where <code>r</code> is the radius of the source box and <code>η &gt;= 1</code> is an adjustable parameter. In dimension <code>N</code>, the default choice is <code>η = √N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.ClusterTree" href="#IFGF.ClusterTree"><code>IFGF.ClusterTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ClusterTree{T,S,D}</code></pre><p>Tree structure used to cluster elements of type <code>V = eltype(T)</code> into containers of type <code>S</code>. The method <code>center(::V)::SVector</code> is required for the clustering algorithms. An additional <code>data</code> field of type <code>D</code> can be associated with each node to store node-specific information (it defaults to <code>D=Nothing</code>).</p><p><strong>Fields:</strong></p><ul><li><code>_elements::T</code> : vector containing the sorted elements.</li><li><code>container::S</code> : container for the elements in the current node.</li><li><code>index_range::UnitRange{Int}</code> : indices of elements contained in the current node.</li><li><code>loc2glob::Vector{Int}</code> : permutation from the local indexing system to the original (global) indexing system used as input in the construction of the tree.</li><li><code>children::Vector{ClusterTree{N,T,D}}</code></li><li><code>parent::ClusterTree{N,T,D}</code></li><li><code>data::D</code> : generic data field of type <code>D</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.ClusterTree-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Any}} where D" href="#IFGF.ClusterTree-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Any}} where D"><code>IFGF.ClusterTree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ClusterTree(elements,splitter;[copy_elements=true])
ClusterTree{D}(points,splitter;[copy_elements=true])</code></pre><p>Construct a <code>ClusterTree</code> from the  given <code>elements</code> using the splitting strategy encoded in <code>splitter</code>. If <code>copy_elements</code> is set to false, the <code>elements</code> argument are directly stored in the <code>ClusterTree</code> and are permuted during the tree construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L132-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.ConeDomainSize" href="#IFGF.ConeDomainSize"><code>IFGF.ConeDomainSize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConeDomainSize</code></pre><p>Use <code>ConeDomainSize(k,ds)</code> to create a function that computes the appropriate meshsize for a given <code>ClusterTree</code> based on the wavenumber <code>k</code> and the reference meshsize <code>ds</code>.</p><p>Calling <code>f(node)</code> will return the meshsize for the given <code>node</code>, where <code>f</code> is a <code>ConeDomainSize</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.DyadicMaxDepthSplitter" href="#IFGF.DyadicMaxDepthSplitter"><code>IFGF.DyadicMaxDepthSplitter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DyadicMaxDepthSplitter &lt;: AbstractSplitter</code></pre><p>Similar to <a href="#IFGF.DyadicSplitter"><code>DyadicSplitter</code></a>, but splits nodes until a maximum <code>depth</code> is reached.</p><p><strong>See also: <a href="#IFGF.AbstractSplitter"><code>AbstractSplitter</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/splitter.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.DyadicMinimalSplitter" href="#IFGF.DyadicMinimalSplitter"><code>IFGF.DyadicMinimalSplitter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DyadicMinimalSplitter &lt;: AbstractSplitter</code></pre><p>Similar to <a href="#IFGF.DyadicSplitter"><code>DyadicSplitter</code></a>, but the boundin boxes are shrank to the minimal axis-aligned boxes at the end.</p><p><strong>See also: <a href="#IFGF.AbstractSplitter"><code>AbstractSplitter</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/splitter.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.DyadicSplitter" href="#IFGF.DyadicSplitter"><code>IFGF.DyadicSplitter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DyadicSplitter &lt;: AbstractSplitter</code></pre><p>Used to split an <code>N</code> dimensional <code>ClusterTree</code> into <code>2^N</code> children until at most <code>nmax</code> points are contained in node.</p><p><strong>See also: <a href="#IFGF.AbstractSplitter"><code>AbstractSplitter</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/splitter.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.Helmholtz" href="#IFGF.Helmholtz"><code>IFGF.Helmholtz</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Helmholtz{N, T}</code></pre><p>Helmholtz equation in <code>N</code> dimension: Δu + k²u= 0. <code>k</code> is the wavenumber of numeric type T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/kernels.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.HyperRectangle" href="#IFGF.HyperRectangle"><code>IFGF.HyperRectangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HyperRectangle{N,T}</code></pre><p>Axis-aligned hyperrectangle in <code>N</code> dimensions given by <code>low_corner::SVector{N,T}</code> and <code>high_corner::SVector{N,T}</code>. By default, <code>T</code> is <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.HyperRectangle-Tuple{StaticArraysCore.SVector, Any}" href="#IFGF.HyperRectangle-Tuple{StaticArraysCore.SVector, Any}"><code>IFGF.HyperRectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HyperRectangle(lc,hc)</code></pre><p>Construct an axis-aligned hyperrectangle with low-corner <code>lc</code> and high-corner <code>hc</code>.</p><p>It is recommended that <code>lc</code> and <code>hc</code> be of type <code>SVector</code> or <code>Tuple</code> to avoid type instabilities.</p><pre><code class="language-julia-repl hljs">julia&gt; IFGF.HyperRectangle((0.0, 0.0), (1.0, 2.0))
IFGF.HyperRectangle{2, Float64}([0.0, 0.0], [1.0, 2.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.IFGFOp" href="#IFGF.IFGFOp"><code>IFGF.IFGFOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IFGFOp{T} &lt;: AbstractMatrix{T}</code></pre><p>High-level structure representing a linear operator with elements of type <code>T</code> and <code>i,j</code> entry given by <code>K(X[i],Y[j])</code>, where <code>K</code> is the underlying kernel function, and <code>X</code> and <code>Y</code> are the elements of the <code>target_tree</code> and <code>source_tree</code>, respectively.</p><p><strong>Fields:</strong></p><ul><li><code>kernel</code> : underlying kernel function</li><li><code>target_tree</code> : tree structure used for clustering the target points</li><li><code>source_tree</code> : tree structure used for clustering the source points</li><li><code>p::NTuple</code>: number of chebyshev poins per dimension used in the interpolation of far interactions</li><li><code>h::NTuple</code>: meshsize in parameter (per dimension) of the largest cones</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L15-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.Laplace" href="#IFGF.Laplace"><code>IFGF.Laplace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Laplace{N}</code></pre><p>Laplace equation in <code>N</code> dimension: Δu = 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/kernels.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.MulBuffer" href="#IFGF.MulBuffer"><code>IFGF.MulBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MulBuffer{T}</code></pre><p>Low-level structure used to hold the interpolation coefficients and values of the current and next level cone interpolants.</p><p>The type paramter <code>T</code> is the type of the interpolant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.SourceTree" href="#IFGF.SourceTree"><code>IFGF.SourceTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const SourceTree{T,S,D}</code></pre><p>Type alias for a <code>ClusterTree</code> with a data field <code>D</code> of type <code>SourceTreeData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.SourceTreeData" href="#IFGF.SourceTreeData"><code>IFGF.SourceTreeData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SourceTreeData{N,T,S}</code></pre><p>Struct used to store data associated with a node of the <code>SourceTree</code>. The parametric type <code>N</code> represents the ambient dimension, <code>T</code> represents the primitive type used to represent the points (e.g. <code>Float32</code> or <code>Float64</code> for single/double precision), and <code>S</code> is the type of node in the near and far field.</p><p><strong>Fields:</strong></p><ul><li><code>msh</code>: uniform cartesian mesh of the interpolation space, indexable by a <code>CartesianIndex</code></li><li><code>conedatadict</code>: dictionary mapping a cone tag <code>I::CartesianIndex</code> to the index range of the interpolation points owned by that cone</li><li><code>farlist</code>: nodes on the target tree that can be evaluated through   interpolation</li><li><code>nearlist</code>: nodes on the target tree that must be evaluated by a direct sum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.TargetTree" href="#IFGF.TargetTree"><code>IFGF.TargetTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const TargetTree{T,S,D}</code></pre><p>Type alias for a <code>ClusterTree</code> with a data field <code>D</code> of type <code>TargetTreeData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/targettree.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.TargetTreeData" href="#IFGF.TargetTreeData"><code>IFGF.TargetTreeData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TargetTreeData</code></pre><p>Struct used to store data associated with a node of the <code>TargetTree</code>. Currently there is nothing there, but maybe one day there will be a downward pass in the target tree, and it will need some fields to store data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/targettree.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.UniformCartesianMesh" href="#IFGF.UniformCartesianMesh"><code>IFGF.UniformCartesianMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UniformCartesianMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>An <code>N</code>-dimensional cartesian grid given as the tensor-product of <code>N</code> one-dimensional <code>LinRange{T}</code> grids.</p><p>Iterating over a <code>UniformCartesianMesh</code> generates the elements which compose the mesh; i.e. the <code>HyperRectangle</code> cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/cartesianmesh.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.UniformCartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{IFGF.HyperRectangle{N, T}, Int64}} where {N, T}" href="#IFGF.UniformCartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{IFGF.HyperRectangle{N, T}, Int64}} where {N, T}"><code>IFGF.UniformCartesianMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UniformCartesianMesh(domain::HyperRectangle,sz::NTuple)
UniformCartesianMesh(domain::HyperRectangle;step::NTuple)</code></pre><p>Construct a uniform <code>UniformCartesianMesh</code> with <code>sz[d]</code> elements along dimension <code>d</code>. If the kwarg <code>step</code> is passed, construct a <code>UniformCartesianMesh</code> with elements of approximate size <code>step</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/cartesianmesh.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.split-Tuple{IFGF.HyperRectangle, Any, Any}" href="#Base.split-Tuple{IFGF.HyperRectangle, Any, Any}"><code>Base.split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split(rec::HyperRectangle[, axis::Int, place])</code></pre><p>Split a hyperrectangle in two along the <code>axis</code> direction at the  position <code>place</code>. Returns a tuple with the two resulting hyperrectangles.</p><p>When no <code>place</code> is given, defaults to splitting in the middle of the axis.</p><p>When no axis and no place are given, defaults to splitting along the largest axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L181-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.union-Tuple{IFGF.HyperRectangle, IFGF.HyperRectangle}" href="#Base.union-Tuple{IFGF.HyperRectangle, IFGF.HyperRectangle}"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">union(r1::HyperRectangle,r2::HyperRectangle)</code></pre><p>Smallest <a href="#IFGF.HyperRectangle"><code>HyperRectangle</code></a> that contains both <code>r1</code> and <code>r2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF._addnewcone!-Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, Any, Any}" href="#IFGF._addnewcone!-Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, Any, Any}"><code>IFGF._addnewcone!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_addnewcone!(node::SourceTree,I::CartesianIndex[, lock])</code></pre><p>If <code>node</code> does not contain cone <code>I</code>, add it to the <code>conedict</code>. Does not set the indices of the interpolation data owned by the cone.</p><p>If <code>lock</code> is passed, the operation is thread-safe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF._binary_split!-Tuple{IFGF.ClusterTree, Any, Any}" href="#IFGF._binary_split!-Tuple{IFGF.ClusterTree, Any, Any}"><code>IFGF._binary_split!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_binary_split!(cluster::ClusterTree,dir,pos;parentcluster=cluster)
_binary_split!(cluster::ClusterTree,f;parentcluster=cluster)</code></pre><p>Split a <code>ClusterTree</code> into two, sorting all elements in the process. For each resulting child assign <code>child.parent=parentcluster</code>.</p><p>Passing a <code>dir</code> and <code>pos</code> arguments splits the <code>container</code> of <code>node</code> along direction <code>dir</code> at position <code>pos</code>, then sorts all points into the resulting  left/right nodes.</p><p>If passed a predicate <code>f</code>, each point is sorted according to whether <code>f(x)</code> returns <code>true</code> (point sorted on the left node) or <code>false</code> (point sorted on the right node). At the end a minimal <code>HyperRectangle</code> containing all left/right points is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L180-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF._compute_cone_list!-NTuple{4, Any}" href="#IFGF._compute_cone_list!-NTuple{4, Any}"><code>IFGF._compute_cone_list!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_compute_cone_list!(partition, p, ds_func)</code></pre><p>For each node in <code>partition</code>, compute the cones which are necessary to cover both the target points on its <code>farlist</code> as well as the interpolation points on its parent&#39;s cones. <code>p</code> denotes the number of interpolation points per dimension, and <code>ds_func(node)</code> gives the meshsize of the domain in interpolation-space for <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L233-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF._compute_interaction_list!-Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, IFGF.ClusterTree{T, S, &lt;:IFGF.TargetTreeData} where {T, S}, Any, Any}" href="#IFGF._compute_interaction_list!-Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, IFGF.ClusterTree{T, S, &lt;:IFGF.TargetTreeData} where {T, S}, Any, Any}"><code>IFGF._compute_interaction_list!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_compute_interaction_list!(source, target, adm)</code></pre><p>For each node in <code>source</code>, compute its <code>nearlist</code> and <code>farlist</code>. The <code>nearlist</code> contains all nodes in <code>target</code> for which the interaction must be computed using the direct summation.  The <code>farlist</code> includes all nodes in <code>target_tree</code> for which an accurate interpolant in available in the source node.</p><p>The <code>adm</code> function is called through <code>adm(target,source)</code> to determine if <code>target</code> is in the <code>farlist</code> of source. When that is not the case we recurse on their children unless both are a leaves, in which case <code>target</code> is added to the <code>nearlist</code> of source.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L169-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF._density_type_from_kernel_type-Tuple{Any}" href="#IFGF._density_type_from_kernel_type-Tuple{Any}"><code>IFGF._density_type_from_kernel_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_density_type_from_kernel_type(T)</code></pre><p>Helper function to compute the expected density <code>V</code> type associated with a kernel type <code>T</code>. For <code>T&lt;:Number</code>, simply return <code>T</code>. For <code>T&lt;:SMatrix</code>, return an <code>SVector</code> with elements of the type <code>eltype(T)</code> and of length <code>size(T,2)</code> so that multiplying an element of type <code>T</code> with an element of type <code>V</code> makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF._init_msh!-Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, Any, Any}" href="#IFGF._init_msh!-Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, Any, Any}"><code>IFGF._init_msh!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_init_msh!(node,domain,ds)</code></pre><p>Create a uniform cartesian mesh of the interpolation domain of <code>node</code> with element spacing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF._tol_to_p-Tuple{IFGF.Laplace{3}, Any}" href="#IFGF._tol_to_p-Tuple{IFGF.Laplace{3}, Any}"><code>IFGF._tol_to_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_tol_to_p(pde, tol::Real)</code></pre><p>Heuristics to convert a tolerance <code>tol</code> to the polynomial order <code>p</code> for the IFGF operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/kernels.jl#L414-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.assemble_ifgf-Tuple{Any, Any, Any}" href="#IFGF.assemble_ifgf-Tuple{Any, Any, Any}"><code>IFGF.assemble_ifgf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble_ifgf(K, X, Y; tol, nmax=250)
assemble_ifgf(K, X, Y; p, nmax=250)</code></pre><p>Construct an approximation of the matrix <code>[K(x,y) for x ∈ X, y ∈ Y]</code> using the <a href="https://arxiv.org/abs/2010.02857">interpolated factored Green function method</a>. The parameter <code>tol</code> controls the error in the approximation, and <code>nmax</code> gives the maximum number of points in a leaf of the dyadic trees used.</p><p>The kernel <code>K</code> must implement <code>wavenumber(::typeof(K)) --&gt; Number</code> to return the kernel&#39;s (typical) wavenumber; for non-oscillatory kernels this is zero.</p><p>When <code>tol</code> is passed, an interpolation order <code>p</code> is estimated based on some heuristic. If you know in advance what interpolation order you want, you can pass that through the keyword arguemnt <code>p</code>. Note that <code>p</code> can be a tuple of order-per-spatial dimension. Increasing <code>p</code> (or decreasing <code>tol</code>) will increas the computational time, and therefore some tuning may be needed to find the right value for your given kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L62-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.bounding_box" href="#IFGF.bounding_box"><code>IFGF.bounding_box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bounding_box(els[, cube=false])</code></pre><p>Compute a <a href="#IFGF.HyperRectangle"><code>HyperRectangle</code></a> that contains the <a href="#IFGF.center-Tuple{IFGF.HyperRectangle}"><code>center</code></a> of all elements in <code>els</code>. If <code>cube==true</code>, the result is a square/cube instead.</p><p>Works for any type that implements <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L151-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.cart2interp-Tuple{Any, IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}}" href="#IFGF.cart2interp-Tuple{Any, IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}}"><code>IFGF.cart2interp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cart2interp(x,c,h)
cart2interp(x,source::SourceTree)</code></pre><p>Map cartesian coordinates <code>x</code> into interpolation coordinates <code>s</code> centered at <code>c</code> and scaled by <code>h</code>. Interpolation coordinates are similar to hyperspherical coordinates (e.g. polar in two-dimensions and spherical in three-dimensions), except that the radial coordinates is replaced by <code>s=h/r</code>.</p><p>If passed a <code>SourceTree</code>, use its <code>center</code> and radius as <code>c</code> and <code>h</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L129-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.center-Tuple{IFGF.HyperRectangle}" href="#IFGF.center-Tuple{IFGF.HyperRectangle}"><code>IFGF.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(Ω)</code></pre><p>Center of the smallest ball containing <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.centered_factor-Tuple{Any, Any, Any}" href="#IFGF.centered_factor-Tuple{Any, Any, Any}"><code>IFGF.centered_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centered_factor(K,x,Y::SourceTree)</code></pre><p>Return a representative scalar value of <code>K(x,y)</code> for <code>y ∈ Y</code>. This is used to help the interpolation of <code>I(x) = ∑ᵢ K(x,yᵢ)</code> where <code>yᵢ ∈ Y</code> and points <code>x</code> in the far field of <code>Y</code>. Defaults to <code>K(x,yc)</code> where <code>yc</code> is the center of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L552-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.cheb_error_estimate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}" href="#IFGF.cheb_error_estimate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}"><code>IFGF.cheb_error_estimate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cheb_error_estimate(coefs::AbstractArray{T,N},dim)</code></pre><p>Given an <code>N</code> dimensional array of coefficients , estimate the relative error commited by the Chebyshev interpolant along dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/chebinterp.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.chebeval-Union{Tuple{SZ}, Tuple{T}, Tuple{N}, Tuple{AbstractArray{T}, StaticArraysCore.SVector{N}, IFGF.HyperRectangle, Val{SZ}}} where {N, T, SZ}" href="#IFGF.chebeval-Union{Tuple{SZ}, Tuple{T}, Tuple{N}, Tuple{AbstractArray{T}, StaticArraysCore.SVector{N}, IFGF.HyperRectangle, Val{SZ}}} where {N, T, SZ}"><code>IFGF.chebeval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chebeval(coefs,x,rec[,sz])</code></pre><p>Evaluate the Chebyshev polynomial defined on <code>rec</code> with coefficients given by <code>coefs</code> at the point <code>x</code>. If the size of <code>coefs</code> is known statically, its size can be passed as a <code>Val</code> using the <code>sz</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/chebinterp.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.chebnodes-Union{Tuple{T}, Tuple{Integer, Type{T}}} where T&lt;:Real" href="#IFGF.chebnodes-Union{Tuple{T}, Tuple{Integer, Type{T}}} where T&lt;:Real"><code>IFGF.chebnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chebnodes(n,[domain])
chebnodes(p::NTuple,[domain])
chebnodes(::Val{P},[domain])</code></pre><p>Return the <code>n</code> Chebyshev nodes of the second kind on the interval <code>[-1,1]</code>.</p><p>If passed a tuple <code>p</code>, return the tensor product of one-dimensinal nodes of size <code>p</code>.</p><p>If passed a <code>Val{P}</code>, statically compute the tensor product nodes.</p><p>Finally, passing a <code>domain::HyperRectangle</code> shifts the interpolation nodes to it.</p><pre><code class="language-julia hljs">lb = (0.,0.)
ub = (3.,2.)
domain = HyperRectangle(lb,ub)
chebnodes((10,5),domain) # generate `10×5` Chebyshev nodes on the `[0,3]×[0,2]` rectangle.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/chebinterp.jl#L17-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.chebtransform_fftw!-Tuple{AbstractArray}" href="#IFGF.chebtransform_fftw!-Tuple{AbstractArray}"><code>IFGF.chebtransform_fftw!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chebtransform_fftw!(vals::AbstractArray[, plan])</code></pre><p>Given a function values on the <code>chebnodes(p)</code>, where <code>p=size(vals)</code>, compute the Chebyshev coefficients in-place. The underlying implementation uses the <code>FFTW</code> library. A pre-computed <code>plan::FFTW.FFTWPlan</code> should be passed for efficiency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/chebinterp.jl#L76-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.chebtransform_native!" href="#IFGF.chebtransform_native!"><code>IFGF.chebtransform_native!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">chebtransform_native!(vals)</code></pre><p>Compute the Chebyshev coefficients given the values of a function on the Chebyshev nodes of the second kind (i.e. the extrema of the Chebyshev polynomials <code>Tₙ</code>). The  result is written in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/chebinterp.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.cone_index-Tuple{StaticArraysCore.SVector, IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}}" href="#IFGF.cone_index-Tuple{StaticArraysCore.SVector, IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}}"><code>IFGF.cone_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cone_index(x::SVector,tree::SourceTree)</code></pre><p>Given a point <code>x</code> in cartesian coordinates, return the index <code>I</code> of the cone in <code>source</code> to which <code>x</code> belongs, as well as its parametric coordinate <code>s</code>.</p><p><strong>See also: <a href="#IFGF.cart2interp-Tuple{Any, IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}}"><code>cart2interp</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L211-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.container-Tuple{IFGF.ClusterTree}" href="#IFGF.container-Tuple{IFGF.ClusterTree}"><code>IFGF.container</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">container(clt::ClusterTree)</code></pre><p>Return the object enclosing all the elements of the <code>clt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.container_type-Union{Tuple{IFGF.ClusterTree{T, S}}, Tuple{S}, Tuple{T}} where {T, S}" href="#IFGF.container_type-Union{Tuple{IFGF.ClusterTree{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>IFGF.container_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">container_type(clt::ClusterTree)</code></pre><p>Type used to enclose the elements of <code>clt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.coords-Tuple{Tuple}" href="#IFGF.coords-Tuple{Tuple}"><code>IFGF.coords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coords(x)</code></pre><p>Return an <code>SVector</code> with the cartesian coordinates associated to a geometrical object <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L220-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.decrement_index" href="#IFGF.decrement_index"><code>IFGF.decrement_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decrement_index(I::CartesianIndex,k[,n=1])</code></pre><p>Equivalent to <a href="#IFGF.increment_index"><code>increment_index</code></a>(I,k,-n)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.depth" href="#IFGF.depth"><code>IFGF.depth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">depth(tree,acc=0)</code></pre><p>Recursive function to compute the depth of <code>node</code> in a a tree-like structure.</p><p>Overload this function if your structure has a more efficient way to compute <code>depth</code> (e.g. if it stores it in a field).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L167-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.diameter-Tuple{IFGF.HyperRectangle}" href="#IFGF.diameter-Tuple{IFGF.HyperRectangle}"><code>IFGF.diameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diameter(Ω)</code></pre><p>Largest distance between <code>x</code> and <code>y</code> for <code>x,y ∈ Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.distance-Tuple{IFGF.ClusterTree, IFGF.ClusterTree}" href="#IFGF.distance-Tuple{IFGF.ClusterTree, IFGF.ClusterTree}"><code>IFGF.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(X::ClusterTree, Y::ClusterTree)</code></pre><p>Distance between the containers of <code>X</code> and <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.distance-Union{Tuple{N}, Tuple{IFGF.HyperRectangle{N}, IFGF.HyperRectangle{N}}} where N" href="#IFGF.distance-Union{Tuple{N}, Tuple{IFGF.HyperRectangle{N}, IFGF.HyperRectangle{N}}} where N"><code>IFGF.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(Ω₁,Ω₂)</code></pre><p>Minimal Euclidean distance between a point <code>x ∈ Ω₁</code> and <code>y ∈ Ω₂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.distance-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.HyperRectangle{N}}} where N" href="#IFGF.distance-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.HyperRectangle{N}}} where N"><code>IFGF.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(x::SVector,r::HyperRectangle)</code></pre><p>The (minimal) Euclidean distance between the point <code>x</code> and any point <code>y ∈ r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.element_index-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.UniformCartesianMesh{N}}} where N" href="#IFGF.element_index-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.UniformCartesianMesh{N}}} where N"><code>IFGF.element_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element_index(s::SVector,m::UniformCartesianMesh)</code></pre><p>Given a point <code>s ∈ m</code>, return the index <code>I</code> of the element in <code>m</code> containing <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L226-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.element_index_for_point-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.UniformCartesianMesh{N}}} where N" href="#IFGF.element_index_for_point-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.UniformCartesianMesh{N}}} where N"><code>IFGF.element_index_for_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element_index_for_point(p::SVector,m::UniformCartesianMesh)</code></pre><p>Given a point <code>p</code>, return the index <code>I</code> of the element in <code>m</code> containing <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/cartesianmesh.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.element_type-Union{Tuple{IFGF.ClusterTree{T}}, Tuple{T}} where T" href="#IFGF.element_type-Union{Tuple{IFGF.ClusterTree{T}}, Tuple{T}} where T"><code>IFGF.element_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element_type(clt::ClusterTree)</code></pre><p>Type of elements sorted in <code>clt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.elements-Tuple{IFGF.ClusterTree}" href="#IFGF.elements-Tuple{IFGF.ClusterTree}"><code>IFGF.elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elements(clt::ClusterTree)</code></pre><p>Iterable list of the elements inside <code>clt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.float_type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T" href="#IFGF.float_type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T"><code>IFGF.float_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">float_type(x)</code></pre><p>Floating type used to represent the underlying structure (e.g. <code>Float32</code>, <code>Float64</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.glob2loc-Tuple{IFGF.ClusterTree}" href="#IFGF.glob2loc-Tuple{IFGF.ClusterTree}"><code>IFGF.glob2loc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">glob2loc(clt::ClusterTree)</code></pre><p>The inverse of <a href="#IFGF.loc2glob-Tuple{IFGF.ClusterTree}"><code>loc2glob(clt)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.increment_index" href="#IFGF.increment_index"><code>IFGF.increment_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">increment_index(I::CartesianIndex,k[,n=1])</code></pre><p>Increment <code>I</code> by <code>n</code> along  the dimension <code>k</code>. This is equivalent to <code>I += n*eₖ</code>, where <code>eₖ</code> is a vector with with <code>1</code> at the  <code>k</code>-th coordinate and zeros elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.index_range-Tuple{IFGF.ClusterTree}" href="#IFGF.index_range-Tuple{IFGF.ClusterTree}"><code>IFGF.index_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_range(clt::ClusterTree)</code></pre><p>Indices of elements in <code>root_elements(clt)</code> which lie inside <code>clt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.interp2cart-Tuple{Any, IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}}" href="#IFGF.interp2cart-Tuple{Any, IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}}"><code>IFGF.interp2cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interp2cart(s,xc,h)
interp2cart(s,source::SourceTree)</code></pre><p>Map interpolation coordinate <code>s</code> into the corresponding cartesian coordinates.</p><p>Interpolation coordinates are similar to <code>polar</code> (in 2d) or <code>spherical</code> (in 3d) coordinates centered at the <code>xc</code>, except that the radial coordinate <code>r</code> is replaced by <code>s = h/r</code>.</p><p>If passed a <code>SourceTree</code> as second argument, call <code>interp2cart(s,xc,h)</code> with <code>xc</code> the center of the <code>SourceTree</code> and <code>h</code> its radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L87-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.interpolation_domain-Union{Tuple{P}, Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, Val{P}}} where P" href="#IFGF.interpolation_domain-Union{Tuple{P}, Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, Val{P}}} where P"><code>IFGF.interpolation_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolation_domain(source::SourceTree)</code></pre><p>Compute the domain (as a <code>HyperRectangle</code>) in interpolation space for which <code>source</code> must provide a covering through its cone interpolants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/sourcetree.jl#L169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.inv_centered_factor-Tuple{Any, Any, Any}" href="#IFGF.inv_centered_factor-Tuple{Any, Any, Any}"><code>IFGF.inv_centered_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv_centered_factor(K,x,Y)</code></pre><p>Inverse of <a href="#IFGF.centered_factor-Tuple{Any, Any, Any}"><code>centered_factor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L564-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.loc2glob-Tuple{IFGF.ClusterTree}" href="#IFGF.loc2glob-Tuple{IFGF.ClusterTree}"><code>IFGF.loc2glob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loc2glob(clt::ClusterTree)</code></pre><p>The permutation from the (local) indexing system of the elements of the <code>clt</code> to the (global) indexes used upon the construction of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.near_interaction!-NTuple{7, Any}" href="#IFGF.near_interaction!-NTuple{7, Any}"><code>IFGF.near_interaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">near_interaction!(C,K,X,Y,σ,I,J)</code></pre><p>Compute <code>C[i] &lt;-- C[i] + ∑ⱼ K(X[i],Y[j])*σ[j]</code> for <code>i ∈ I</code>, <code>j ∈ J</code>. The default implementation simply does a double loop over all <code>i ∈ I</code> and <code>j ∈ J</code>, but you override this method for the type of your own custom kernel <code>K</code> if you have a fast way of computing the full product in-place (e.g. using SIMD instructions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L533-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.partition_by_depth-Tuple{Any}" href="#IFGF.partition_by_depth-Tuple{Any}"><code>IFGF.partition_by_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_by_depth(tree)</code></pre><p>Given a <code>tree</code>, return a <code>partition</code> vector whose <code>i</code>-th entry stores all the nodes in <code>tree</code> with <code>depth=i-1</code>. Empty nodes are not added to the partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.radius-Tuple{IFGF.HyperRectangle}" href="#IFGF.radius-Tuple{IFGF.HyperRectangle}"><code>IFGF.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius(Ω)</code></pre><p>Half the <a href="#IFGF.diameter-Tuple{IFGF.HyperRectangle}"><code>diameter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.real_and_imag-Union{Tuple{AbstractArray{Complex{T}, 1}}, Tuple{T}} where T&lt;:Real" href="#IFGF.real_and_imag-Union{Tuple{AbstractArray{Complex{T}, 1}}, Tuple{T}} where T&lt;:Real"><code>IFGF.real_and_imag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real_and_imag(v)</code></pre><p>Return a view over the real and imaginary parts of a complex vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L272-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.return_type-Tuple{Any, Vararg{Any}}" href="#IFGF.return_type-Tuple{Any, Vararg{Any}}"><code>IFGF.return_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">return_type(f[,args...])</code></pre><p>The type returned by <code>f(args...)</code>, where <code>args</code> is a tuple of types. Falls back to <code>Base.promote_op</code> by default.</p><p>A functors of type <code>T</code> with a known return type should extend <code>return_type(::T,args...)</code> to avoid relying on <code>promote_op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L153-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.root_elements-Tuple{IFGF.ClusterTree}" href="#IFGF.root_elements-Tuple{IFGF.ClusterTree}"><code>IFGF.root_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root_elements(clt::ClusterTree)</code></pre><p>The elements contained in the root of the tree to which <code>clt</code> belongs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/clustertree.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.section-Union{Tuple{D}, Tuple{IFGF.HyperRectangle{D}, Integer}} where D" href="#IFGF.section-Union{Tuple{D}, Tuple{IFGF.HyperRectangle{D}, Integer}} where D"><code>IFGF.section</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">section(rec::HyperRectangle{D},ax)</code></pre><p>Return the dimension <code>D-1</code> <code>HyperRectangle</code> obtained by deleting the coordinates at the <code>ax</code> dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/hyperrectangle.jl#L210-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.share_interp_data" href="#IFGF.share_interp_data"><code>IFGF.share_interp_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">share_interp_data(mode=true)</code></pre><p>If set to <code>true</code>, neighboring cone interpolants will share their interpolation data (which are, in this case, computed only once).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.should_split-Tuple{Any, Any, IFGF.AbstractSplitter}" href="#IFGF.should_split-Tuple{Any, Any, IFGF.AbstractSplitter}"><code>IFGF.should_split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">should_split(clt::ClusterTree, depth, splitter::AbstractSplitter)</code></pre><p>Determine whether or not a <code>ClusterTree</code> should be further divided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/splitter.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.split!-Tuple{Any, IFGF.AbstractSplitter}" href="#IFGF.split!-Tuple{Any, IFGF.AbstractSplitter}"><code>IFGF.split!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split!(clt::ClusterTree,splitter::AbstractSplitter)</code></pre><p>Divide <code>clt</code> using the strategy implemented by <code>splitter</code>. This function is reponsible of assigning the <code>children</code> and <code>parent</code> fields, as well as of permuting the data of <code>clt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/splitter.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.svector-Tuple{Any, Any}" href="#IFGF.svector-Tuple{Any, Any}"><code>IFGF.svector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svector(f,n)</code></pre><p>Create an <code>SVector</code> of length n, computing each element as f(i), where <code>i ∈ 1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.transfer_factor-Tuple{Any, Any, Any}" href="#IFGF.transfer_factor-Tuple{Any, Any, Any}"><code>IFGF.transfer_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer_factor(K,x,Y::SourceTree)</code></pre><p>Ratio between the centered factor of <code>Y</code> and the centered factor of its parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L574-L578">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.use_fftw" href="#IFGF.use_fftw"><code>IFGF.use_fftw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">use_fftw(mode=true)</code></pre><p>Use the <a href="http://www.fftw.org">FFTW</a> library for computing the Chebyshev transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.use_minimal_conedomain" href="#IFGF.use_minimal_conedomain"><code>IFGF.use_minimal_conedomain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">use_minimal_conedomain(mode=true)</code></pre><p>If set to <code>true</code>, the minimal domain for the cone interpolants will be used by calling <a href="#IFGF.interpolation_domain-Union{Tuple{P}, Tuple{IFGF.ClusterTree{T, S, &lt;:IFGF.SourceTreeData} where {T, S}, Val{P}}} where P"><code>interpolation_domain</code></a> during the contruction of the active cones.</p><p>While setting this to <code>true</code> reduces the memory footprint by creating fewer cones, it also increases the time to assemble the <code>IFGFOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.usethreads" href="#IFGF.usethreads"><code>IFGF.usethreads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">usethreads(mode=true)</code></pre><p>Enable/disable thread usage globally for the <code>IFGF</code> module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IFGF.wavenumber" href="#IFGF.wavenumber"><code>IFGF.wavenumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wavenumber(K::Function)</code></pre><p>For oscillatory kernels, return the characteristic wavenumber (i.e <code>2π</code> divided by he wavelength). For non-oscillatory kernels, return <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/utils.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{AbstractVector, IFGF.IFGFOp, AbstractVector, Number, Number}" href="#LinearAlgebra.mul!-Tuple{AbstractVector, IFGF.IFGFOp, AbstractVector, Number, Number}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul!(y,A::IFGFOp,x,a,b;global_index=true)</code></pre><p>Setting <code>global_index=false</code> uses the internal indexing system of the <code>IFGFOp</code>, and therefore does not permute the vectors <code>x</code> and <code>y</code> to perform the multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/IFGF.jl/blob/dee3c04e7f82e4a97807877c264aaae682c39617/src/ifgfoperator.jl#L290-L296">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 13 February 2024 22:23">Tuesday 13 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
