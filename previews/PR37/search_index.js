var documenterSearchIndex = {"docs":
[{"location":"references/#references-section","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Modules = [IFGF]","category":"page"},{"location":"references/#IFGF.AbstractPDE","page":"References","title":"IFGF.AbstractPDE","text":"abstract type AbstractPDE{N}\n\nA partial differential equation in dimension N. AbstractPDE types are used to define AbstractPDEKernels.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.AbstractSplitter","page":"References","title":"IFGF.AbstractSplitter","text":"abstract type AbstractSplitter\n\nAn AbstractSplitter is used to split a ClusterTree. The interface requires the following methods:\n\nshould_split(clt,splitter) : return a Bool determining if the ClusterTree should be further divided\nsplit!(clt,splitter) : perform the splitting of the ClusterTree handling the necessary data sorting.\n\nSee DyadicSplitter for an example of an implementation.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.AdmissibilityCondition","page":"References","title":"IFGF.AdmissibilityCondition","text":"struct AdmissibilityCondition\n\nFunctor used to determine if the interaction between a target and a source can be approximated using an interpolation scheme.\n\nA target and source are admissible under this admissiblility condition if the target box lies farther than r*η away, where r is the radius of the source box and η >= 1 is an adjustable parameter. In dimension N, the default choice is η = √N.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.ClusterTree","page":"References","title":"IFGF.ClusterTree","text":"mutable struct ClusterTree{T,S,D}\n\nTree structure used to cluster elements of type V = eltype(T) into containers of type S. The method center(::V)::SVector is required for the clustering algorithms. An additional data field of type D can be associated with each node to store node-specific information (it defaults to D=Nothing).\n\nFields:\n\n_elements::T : vector containing the sorted elements.\ncontainer::S : container for the elements in the current node.\nindex_range::UnitRange{Int} : indices of elements contained in the current node.\nloc2glob::Vector{Int} : permutation from the local indexing system to the original (global) indexing system used as input in the construction of the tree.\nchildren::Vector{ClusterTree{N,T,D}}\nparent::ClusterTree{N,T,D}\ndata::D : generic data field of type D.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.ClusterTree-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Any}} where D","page":"References","title":"IFGF.ClusterTree","text":"ClusterTree(elements,splitter;[copy_elements=true])\nClusterTree{D}(points,splitter;[copy_elements=true])\n\nConstruct a ClusterTree from the  given elements using the splitting strategy encoded in splitter. If copy_elements is set to false, the elements argument are directly stored in the ClusterTree and are permuted during the tree construction.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.ConeDomainSize","page":"References","title":"IFGF.ConeDomainSize","text":"struct ConeDomainSize\n\nUse ConeDomainSize(k,ds) to create a function that computes the appropriate meshsize for a given ClusterTree based on the wavenumber k and the reference meshsize ds.\n\nCalling f(node) will return the meshsize for the given node, where f is a ConeDomainSize object.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.DyadicMaxDepthSplitter","page":"References","title":"IFGF.DyadicMaxDepthSplitter","text":"struct DyadicMaxDepthSplitter <: AbstractSplitter\n\nSimilar to DyadicSplitter, but splits nodes until a maximum depth is reached.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.DyadicMinimalSplitter","page":"References","title":"IFGF.DyadicMinimalSplitter","text":"struct DyadicMinimalSplitter <: AbstractSplitter\n\nSimilar to DyadicSplitter, but the boundin boxes are shrank to the minimal axis-aligned boxes at the end.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.DyadicSplitter","page":"References","title":"IFGF.DyadicSplitter","text":"struct DyadicSplitter <: AbstractSplitter\n\nUsed to split an N dimensional ClusterTree into 2^N children until at most nmax points are contained in node.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.HyperRectangle","page":"References","title":"IFGF.HyperRectangle","text":"struct HyperRectangle{N,T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}. By default, T is Float64.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.HyperRectangle-Tuple{StaticArraysCore.SVector, Any}","page":"References","title":"IFGF.HyperRectangle","text":"HyperRectangle(lc,hc)\n\nConstruct an axis-aligned hyperrectangle with low-corner lc and high-corner hc.\n\nIt is recommended that lc and hc be of type SVector or Tuple to avoid type instabilities.\n\njulia> IFGF.HyperRectangle((0.0, 0.0), (1.0, 2.0))\nIFGF.HyperRectangle{2, Float64}([0.0, 0.0], [1.0, 2.0])\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.IFGFOp","page":"References","title":"IFGF.IFGFOp","text":"struct IFGFOp{T} <: AbstractMatrix{T}\n\nHigh-level structure representing a linear operator with elements of type T and i,j entry given by K(X[i],Y[j]), where K is the underlying kernel function, and X and Y are the elements of the target_tree and source_tree, respectively.\n\nFields:\n\nkernel : underlying kernel function\ntarget_tree : tree structure used for clustering the target points\nsource_tree : tree structure used for clustering the source points\np::NTuple: number of chebyshev poins per dimension used in the interpolation of far interactions\nh::NTuple: meshsize in parameter (per dimension) of the largest cones\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.Laplace","page":"References","title":"IFGF.Laplace","text":"struct Laplace{N}\n\nLaplace equation in N dimension: Δu = 0.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.MulBuffer","page":"References","title":"IFGF.MulBuffer","text":"struct MulBuffer{T}\n\nLow-level structure used to hold the interpolation coefficients and values of the current and next level cone interpolants.\n\nThe type paramter T is the type of the interpolant.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.SourceTree","page":"References","title":"IFGF.SourceTree","text":"const SourceTree{T,S,D}\n\nType alias for a ClusterTree with a data field D of type SourceTreeData.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.SourceTreeData","page":"References","title":"IFGF.SourceTreeData","text":"mutable struct SourceTreeData{N,T,S}\n\nStruct used to store data associated with a node of the SourceTree. The parametric type N represents the ambient dimension, T represents the primitive type used to represent the points (e.g. Float32 or Float64 for single/double precision), and S is the type of node in the near and far field.\n\nFields:\n\nmsh: uniform cartesian mesh of the interpolation space, indexable by a CartesianIndex\nconedatadict: dictionary mapping a cone tag I::CartesianIndex to the index range of the interpolation points owned by that cone\nfarlist: nodes on the target tree that can be evaluated through   interpolation\nnearlist: nodes on the target tree that must be evaluated by a direct sum.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.TargetTree","page":"References","title":"IFGF.TargetTree","text":"const TargetTree{T,S,D}\n\nType alias for a ClusterTree with a data field D of type TargetTreeData.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.TargetTreeData","page":"References","title":"IFGF.TargetTreeData","text":"struct TargetTreeData\n\nStruct used to store data associated with a node of the TargetTree. Currently there is nothing there, but maybe one day there will be a downward pass in the target tree, and it will need some fields to store data.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.UniformCartesianMesh","page":"References","title":"IFGF.UniformCartesianMesh","text":"struct UniformCartesianMesh{N,T} <: AbstractMesh{N,T}\n\nAn N-dimensional cartesian grid given as the tensor-product of N one-dimensional LinRange{T} grids.\n\nIterating over a UniformCartesianMesh generates the elements which compose the mesh; i.e. the HyperRectangle cells.\n\n\n\n\n\n","category":"type"},{"location":"references/#IFGF.UniformCartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{IFGF.HyperRectangle{N, T}, Int64}} where {N, T}","page":"References","title":"IFGF.UniformCartesianMesh","text":"UniformCartesianMesh(domain::HyperRectangle,sz::NTuple)\nUniformCartesianMesh(domain::HyperRectangle;step::NTuple)\n\nConstruct a uniform UniformCartesianMesh with sz[d] elements along dimension d. If the kwarg step is passed, construct a UniformCartesianMesh with elements of approximate size step.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.split-Tuple{IFGF.HyperRectangle, Any, Any}","page":"References","title":"Base.split","text":"split(rec::HyperRectangle[, axis::Int, place])\n\nSplit a hyperrectangle in two along the axis direction at the  position place. Returns a tuple with the two resulting hyperrectangles.\n\nWhen no place is given, defaults to splitting in the middle of the axis.\n\nWhen no axis and no place are given, defaults to splitting along the largest axis.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.union-Tuple{IFGF.HyperRectangle, IFGF.HyperRectangle}","page":"References","title":"Base.union","text":"union(r1::HyperRectangle,r2::HyperRectangle)\n\nSmallest HyperRectangle that contains both r1 and r2.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._addnewcone!-Tuple{IFGF.ClusterTree{T, S, <:IFGF.SourceTreeData} where {T, S}, Any, Any}","page":"References","title":"IFGF._addnewcone!","text":"_addnewcone!(node::SourceTree,I::CartesianIndex[, lock])\n\nIf node does not contain cone I, add it to the conedict. Does not set the indices of the interpolation data owned by the cone.\n\nIf lock is passed, the operation is thread-safe.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._binary_split!-Tuple{IFGF.ClusterTree, Any, Any}","page":"References","title":"IFGF._binary_split!","text":"_binary_split!(cluster::ClusterTree,dir,pos;parentcluster=cluster)\n_binary_split!(cluster::ClusterTree,f;parentcluster=cluster)\n\nSplit a ClusterTree into two, sorting all elements in the process. For each resulting child assign child.parent=parentcluster.\n\nPassing a dir and pos arguments splits the container of node along direction dir at position pos, then sorts all points into the resulting  left/right nodes.\n\nIf passed a predicate f, each point is sorted according to whether f(x) returns true (point sorted on the left node) or false (point sorted on the right node). At the end a minimal HyperRectangle containing all left/right points is created.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._compute_cone_list!-NTuple{4, Any}","page":"References","title":"IFGF._compute_cone_list!","text":"_compute_cone_list!(partition, p, ds_func)\n\nFor each node in partition, compute the cones which are necessary to cover both the target points on its farlist as well as the interpolation points on its parent's cones. p denotes the number of interpolation points per dimension, and ds_func(node) gives the meshsize of the domain in interpolation-space for node.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._compute_interaction_list!-Tuple{IFGF.ClusterTree{T, S, <:IFGF.SourceTreeData} where {T, S}, IFGF.ClusterTree{T, S, <:IFGF.TargetTreeData} where {T, S}, Any, Any}","page":"References","title":"IFGF._compute_interaction_list!","text":"_compute_interaction_list!(source, target, adm)\n\nFor each node in source, compute its nearlist and farlist. The nearlist contains all nodes in target for which the interaction must be computed using the direct summation.  The farlist includes all nodes in target_tree for which an accurate interpolant in available in the source node.\n\nThe adm function is called through adm(target,source) to determine if target is in the farlist of source. When that is not the case we recurse on their children unless both are a leaves, in which case target is added to the nearlist of source.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._density_type_from_kernel_type-Tuple{Any}","page":"References","title":"IFGF._density_type_from_kernel_type","text":"_density_type_from_kernel_type(T)\n\nHelper function to compute the expected density V type associated with a kernel type T. For T<:Number, simply return T. For T<:SMatrix, return an SVector with elements of the type eltype(T) and of length size(T,2) so that multiplying an element of type T with an element of type V makes sense.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._init_msh!-Tuple{IFGF.ClusterTree{T, S, <:IFGF.SourceTreeData} where {T, S}, Any, Any}","page":"References","title":"IFGF._init_msh!","text":"_init_msh!(node,domain,ds)\n\nCreate a uniform cartesian mesh of the interpolation domain of node with element spacing ds.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF._tol_to_p-Tuple{IFGF.Laplace{3}, Any}","page":"References","title":"IFGF._tol_to_p","text":"_tol_to_p(pde, tol::Real)\n\nHeuristics to convert a tolerance tol to the polynomial order p for the IFGF operator.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.assemble_ifgf-Tuple{Any, Any, Any}","page":"References","title":"IFGF.assemble_ifgf","text":"assemble_ifgf(K, X, Y; tol, nmax=250)\nassemble_ifgf(K, X, Y; p, nmax=250)\n\nConstruct an approximation of the matrix [K(x,y) for x ∈ X, y ∈ Y] using the interpolated factored Green function method. The parameter tol controls the error in the approximation, and nmax gives the maximum number of points in a leaf of the dyadic trees used.\n\nThe kernel K must implement wavenumber(::typeof(K)) --> Number to return the kernel's (typical) wavenumber; for non-oscillatory kernels this is zero.\n\nWhen tol is passed, an interpolation order p is estimated based on some heuristic. If you know in advance what interpolation order you want, you can pass that through the keyword arguemnt p. Note that p can be a tuple of order-per-spatial dimension. Increasing p (or decreasing tol) will increas the computational time, and therefore some tuning may be needed to find the right value for your given kernel.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.bounding_box","page":"References","title":"IFGF.bounding_box","text":"bounding_box(els[, cube=false])\n\nCompute a HyperRectangle that contains the center of all elements in els. If cube==true, the result is a square/cube instead.\n\nWorks for any type that implements center.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.cart2interp-Tuple{Any, IFGF.ClusterTree{T, S, <:IFGF.SourceTreeData} where {T, S}}","page":"References","title":"IFGF.cart2interp","text":"cart2interp(x,c,h)\ncart2interp(x,source::SourceTree)\n\nMap cartesian coordinates x into interpolation coordinates s centered at c and scaled by h. Interpolation coordinates are similar to hyperspherical coordinates (e.g. polar in two-dimensions and spherical in three-dimensions), except that the radial coordinates is replaced by s=h/r.\n\nIf passed a SourceTree, use its center and radius as c and h respectively.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.center-Tuple{IFGF.HyperRectangle}","page":"References","title":"IFGF.center","text":"center(Ω)\n\nCenter of the smallest ball containing Ω.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.centered_factor-Tuple{Any, Any, Any}","page":"References","title":"IFGF.centered_factor","text":"centered_factor(K,x,Y::SourceTree)\n\nReturn a representative scalar value of K(x,y) for y ∈ Y. This is used to help the interpolation of I(x) = ∑ᵢ K(x,yᵢ) where yᵢ ∈ Y and points x in the far field of Y. Defaults to K(x,yc) where yc is the center of Y.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.cheb_error_estimate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}","page":"References","title":"IFGF.cheb_error_estimate","text":"cheb_error_estimate(coefs::AbstractArray{T,N},dim)\n\nGiven an N dimensional array of coefficients , estimate the relative error commited by the Chebyshev interpolant along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.chebeval-Tuple","page":"References","title":"IFGF.chebeval","text":"chebeval(coefs,x,rec[,sz])\n\nEvaluate the Chebyshev polynomial defined on rec with coefficients given by coefs at the point x. If the size of coefs is known statically, its size can be passed as a Val using the sz argument.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.chebeval_novec-Union{Tuple{SZ}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N}, IFGF.HyperRectangle, Val{SZ}}} where {N, SZ}","page":"References","title":"IFGF.chebeval_novec","text":"chebeval_novec(coefs,x,rec[,sz])\n\nImplementation of chebeval using a Clenshaw summation without vectorization.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.chebeval_vec-Union{Tuple{SZ}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, <:Real}, IFGF.HyperRectangle, Val{SZ}}} where {N, SZ}","page":"References","title":"IFGF.chebeval_vec","text":"chebeval_vec(coefs,x,rec[,sz])\n\nImplementation of chebeval using a Clenshaw summation wiht vectorization.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.chebnodes-Union{Tuple{T}, Tuple{Integer, Type{T}}} where T<:Real","page":"References","title":"IFGF.chebnodes","text":"chebnodes(n,[domain])\nchebnodes(p::NTuple,[domain])\nchebnodes(::Val{P},[domain])\n\nReturn the n Chebyshev nodes of the second kind on the interval [-1,1].\n\nIf passed a tuple p, return the tensor product of one-dimensinal nodes of size p.\n\nIf passed a Val{P}, statically compute the tensor product nodes.\n\nFinally, passing a domain::HyperRectangle shifts the interpolation nodes to it.\n\nlb = (0.,0.)\nub = (3.,2.)\ndomain = HyperRectangle(lb,ub)\nchebnodes((10,5),domain) # generate `10×5` Chebyshev nodes on the `[0,3]×[0,2]` rectangle.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.chebtransform_fftw!-Tuple{AbstractArray}","page":"References","title":"IFGF.chebtransform_fftw!","text":"chebtransform_fftw!(vals::AbstractArray[, plan])\n\nGiven a function values on the chebnodes(p), where p=size(vals), compute the Chebyshev coefficients in-place. The underlying implementation uses the FFTW library. A pre-computed plan::FFTW.FFTWPlan should be passed for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.chebtransform_native!","page":"References","title":"IFGF.chebtransform_native!","text":"chebtransform_native!(vals)\n\nCompute the Chebyshev coefficients given the values of a function on the Chebyshev nodes of the second kind (i.e. the extrema of the Chebyshev polynomials Tₙ). The  result is written in-place.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.cone_index-Tuple{StaticArraysCore.SVector, IFGF.ClusterTree{T, S, <:IFGF.SourceTreeData} where {T, S}}","page":"References","title":"IFGF.cone_index","text":"cone_index(x::SVector,tree::SourceTree)\n\nGiven a point x in cartesian coordinates, return the index I of the cone in source to which x belongs, as well as its parametric coordinate s.\n\nSee also: cart2interp\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.container-Tuple{IFGF.ClusterTree}","page":"References","title":"IFGF.container","text":"container(clt::ClusterTree)\n\nReturn the object enclosing all the elements of the clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.container_type-Union{Tuple{IFGF.ClusterTree{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"References","title":"IFGF.container_type","text":"container_type(clt::ClusterTree)\n\nType used to enclose the elements of clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.coords-Tuple{Tuple}","page":"References","title":"IFGF.coords","text":"coords(x)\n\nReturn an SVector with the cartesian coordinates associated to a geometrical object x.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.decrement_index","page":"References","title":"IFGF.decrement_index","text":"decrement_index(I::CartesianIndex,k[,n=1])\n\nEquivalent to increment_index(I,k,-n)\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.depth","page":"References","title":"IFGF.depth","text":"depth(tree,acc=0)\n\nRecursive function to compute the depth of node in a a tree-like structure.\n\nOverload this function if your structure has a more efficient way to compute depth (e.g. if it stores it in a field).\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.diameter-Tuple{IFGF.HyperRectangle}","page":"References","title":"IFGF.diameter","text":"diameter(Ω)\n\nLargest distance between x and y for x,y ∈ Ω.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.distance-Tuple{IFGF.ClusterTree, IFGF.ClusterTree}","page":"References","title":"IFGF.distance","text":"distance(X::ClusterTree, Y::ClusterTree)\n\nDistance between the containers of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.distance-Union{Tuple{N}, Tuple{IFGF.HyperRectangle{N}, IFGF.HyperRectangle{N}}} where N","page":"References","title":"IFGF.distance","text":"distance(Ω₁,Ω₂)\n\nMinimal Euclidean distance between a point x ∈ Ω₁ and y ∈ Ω₂.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.distance-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.HyperRectangle{N}}} where N","page":"References","title":"IFGF.distance","text":"distance(x::SVector,r::HyperRectangle)\n\nThe (minimal) Euclidean distance between the point x and any point y ∈ r.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.element_index-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.UniformCartesianMesh{N}}} where N","page":"References","title":"IFGF.element_index","text":"element_index(s::SVector,m::UniformCartesianMesh)\n\nGiven a point s ∈ m, return the index I of the element in m containing s.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.element_index_for_point-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, IFGF.UniformCartesianMesh{N}}} where N","page":"References","title":"IFGF.element_index_for_point","text":"element_index_for_point(p::SVector,m::UniformCartesianMesh)\n\nGiven a point p, return the index I of the element in m containing p.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.element_type-Union{Tuple{IFGF.ClusterTree{T}}, Tuple{T}} where T","page":"References","title":"IFGF.element_type","text":"element_type(clt::ClusterTree)\n\nType of elements sorted in clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.elements-Tuple{IFGF.ClusterTree}","page":"References","title":"IFGF.elements","text":"elements(clt::ClusterTree)\n\nIterable list of the elements inside clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.float_type-Union{Tuple{IFGF.HyperRectangle{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"References","title":"IFGF.float_type","text":"float_type(rec::HyperRectangle)\n\nFloating type used the underlying structure (e.g. Float32, Float64).\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.glob2loc-Tuple{IFGF.ClusterTree}","page":"References","title":"IFGF.glob2loc","text":"glob2loc(clt::ClusterTree)\n\nThe inverse of loc2glob(clt).\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.increment_index","page":"References","title":"IFGF.increment_index","text":"increment_index(I::CartesianIndex,k[,n=1])\n\nIncrement I by n along  the dimension k. This is equivalent to I += n*eₖ, where eₖ is a vector with with 1 at the  k-th coordinate and zeros elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.index_range-Tuple{IFGF.ClusterTree}","page":"References","title":"IFGF.index_range","text":"index_range(clt::ClusterTree)\n\nIndices of elements in root_elements(clt) which lie inside clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.interp2cart-Tuple{Any, IFGF.ClusterTree{T, S, <:IFGF.SourceTreeData} where {T, S}}","page":"References","title":"IFGF.interp2cart","text":"interp2cart(s,xc,h)\ninterp2cart(s,source::SourceTree)\n\nMap interpolation coordinate s into the corresponding cartesian coordinates.\n\nInterpolation coordinates are similar to polar (in 2d) or spherical (in 3d) coordinates centered at the xc, except that the radial coordinate r is replaced by s = h/r.\n\nIf passed a SourceTree as second argument, call interp2cart(s,xc,h) with xc the center of the SourceTree and h its radius.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.interpolation_domain-Union{Tuple{P}, Tuple{Td}, Tuple{N}, Tuple{IFGF.ClusterTree{N, Td, <:IFGF.SourceTreeData}, Val{P}}} where {N, Td, P}","page":"References","title":"IFGF.interpolation_domain","text":"interpolation_domain(source::SourceTree)\n\nCompute the domain (as a HyperRectangle) in interpolation space for which source must provide a covering through its cone interpolants.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.inv_centered_factor-Tuple{Any, Any, Any}","page":"References","title":"IFGF.inv_centered_factor","text":"inv_centered_factor(K,x,Y)\n\nInverse of centered_factor.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.loc2glob-Tuple{IFGF.ClusterTree}","page":"References","title":"IFGF.loc2glob","text":"loc2glob(clt::ClusterTree)\n\nThe permutation from the (local) indexing system of the elements of the clt to the (global) indexes used upon the construction of the tree.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.near_interaction!-NTuple{7, Any}","page":"References","title":"IFGF.near_interaction!","text":"near_interaction!(C,K,X,Y,σ,I,J)\n\nCompute C[i] <-- C[i] + ∑ⱼ K(X[i],Y[j])*σ[j] for i ∈ I, j ∈ J. The default implementation simply does a double loop over all i ∈ I and j ∈ J, but you override this method for the type of your own custom kernel K if you have a fast way of computing the full product in-place (e.g. using SIMD instructions).\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.partition_by_depth-Tuple{Any}","page":"References","title":"IFGF.partition_by_depth","text":"partition_by_depth(tree)\n\nGiven a tree, return a partition vector whose i-th entry stores all the nodes in tree with depth=i-1. Empty nodes are not added to the partition.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.radius-Tuple{IFGF.HyperRectangle}","page":"References","title":"IFGF.radius","text":"radius(Ω)\n\nHalf the diameter.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.real_and_imag-Union{Tuple{AbstractArray{Complex{T}, 1}}, Tuple{T}} where T<:Real","page":"References","title":"IFGF.real_and_imag","text":"real_and_imag(v)\n\nReturn a view over the real and imaginary parts of a complex vector v.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.return_type-Tuple{Any, Vararg{Any}}","page":"References","title":"IFGF.return_type","text":"return_type(f[,args...])\n\nThe type returned by f(args...), where args is a tuple of types. Falls back to Base.promote_op by default.\n\nA functors of type T with a known return type should extend return_type(::T,args...) to avoid relying on promote_op.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.root_elements-Tuple{IFGF.ClusterTree}","page":"References","title":"IFGF.root_elements","text":"root_elements(clt::ClusterTree)\n\nThe elements contained in the root of the tree to which clt belongs.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.section-Union{Tuple{D}, Tuple{IFGF.HyperRectangle{D}, Integer}} where D","page":"References","title":"IFGF.section","text":"section(rec::HyperRectangle{D},ax)\n\nReturn the dimension D-1 HyperRectangle obtained by deleting the coordinates at the ax dimension.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.share_interp_data","page":"References","title":"IFGF.share_interp_data","text":"share_interp_data(mode=true)\n\nIf set to true, neighboring cone interpolants will share their interpolation data (which are, in this case, computed only once).\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.should_split-Tuple{Any, Any, IFGF.AbstractSplitter}","page":"References","title":"IFGF.should_split","text":"should_split(clt::ClusterTree, depth, splitter::AbstractSplitter)\n\nDetermine whether or not a ClusterTree should be further divided.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.split!-Tuple{Any, IFGF.AbstractSplitter}","page":"References","title":"IFGF.split!","text":"split!(clt::ClusterTree,splitter::AbstractSplitter)\n\nDivide clt using the strategy implemented by splitter. This function is reponsible of assigning the children and parent fields, as well as of permuting the data of clt.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.svector-Tuple{Any, Any}","page":"References","title":"IFGF.svector","text":"svector(f,n)\n\nCreate an SVector of length n, computing each element as f(i), where i ∈ 1:n.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.transfer_factor-Tuple{Any, Any, Any}","page":"References","title":"IFGF.transfer_factor","text":"transfer_factor(K,x,Y::SourceTree)\n\nRatio between the centered factor of Y and the centered factor of its parent.\n\n\n\n\n\n","category":"method"},{"location":"references/#IFGF.use_fftw","page":"References","title":"IFGF.use_fftw","text":"use_fftw(mode=true)\n\nUse the FFTW library for computing the Chebyshev transform.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.use_minimal_conedomain","page":"References","title":"IFGF.use_minimal_conedomain","text":"use_minimal_conedomain(mode=true)\n\nIf set to true, the minimal domain for the cone interpolants will be used by calling interpolation_domain during the contruction of the active cones.\n\nWhile setting this to true reduces the memory footprint by creating fewer cones, it also increases the time to assemble the IFGFOperator.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.use_vectorized_chebeval","page":"References","title":"IFGF.use_vectorized_chebeval","text":"use_vectorized_chebeval(mode=true)\n\nUse a vectorized version of the Chebyshev evaluation routine. Calling this function will redefine chebeval to point to either chebeval_vec or chebeval_novec, and thus may trigger code recompilation.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.usethreads","page":"References","title":"IFGF.usethreads","text":"usethreads(mode=true)\n\nEnable/disable thread usage globally for the IFGF module.\n\n\n\n\n\n","category":"function"},{"location":"references/#IFGF.wavenumber","page":"References","title":"IFGF.wavenumber","text":"wavenumber(K::Function)\n\nFor oscillatory kernels, return the characteristic wavenumber (i.e 2π divided by he wavelength). For non-oscillatory kernels, return 0.\n\n\n\n\n\n","category":"function"},{"location":"references/#LinearAlgebra.mul!-Tuple{AbstractVector, IFGF.IFGFOp, AbstractVector, Number, Number}","page":"References","title":"LinearAlgebra.mul!","text":"mul!(y,A::IFGFOp,x,a,b;global_index=true)\n\nSetting global_index=false uses the internal indexing system of the IFGFOp, and therefore does not permute the vectors x and y to perform the multiplication.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = IFGF","category":"page"},{"location":"#home-section","page":"Home","title":"IFGF.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia implementation of the Interpolated Factored Green Function Method (IFGF) on adaptive trees","category":"page"},{"location":"#introduction-section","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements an algorithm for approximating the forward map (i.e. the matrix-vector product) of certain kernel matrices, where kernel matrix will be used to refer to any matrix A in mathbbF^mtimes n whose entries can be computed from the following three components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"a vector of target elements X = left boldsymbolx_i right_i=1^m \na vector of source elements Y = left boldsymboly_i right_i=1^n \na kernel function K(xy)  X times Y to mathbbF, where mathbbF is the return type of the kernel (and of the underlying matrix)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The entries of a kernel matrix are given by the explicit formula A_ij = K(boldsymbolx_iboldsymboly_j). Typically, X and Y are vectors of points in mathbbR^d, and K is a function mapping pairs of points into mathbbR or mathbbC.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provided K has sufficient structure, an approximation of the product Ax can be computed in linear or log-linear complexity by various well known algorithms such as the Fast Multipole Method or hierarchical matrices; this package implements another acceleration algorithm named Interpolated Factored Green Function method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To illustrate how to set up the IFGFOp, let X and Y be a set of random points on the unit cube, and take K to be the Helmholtz Green function in three dimensions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    K(boldsymbolxboldsymboly) = frace^ikboldsymbolx-boldsymboly4pi boldsymbolx-boldsymboly","category":"page"},{"location":"","page":"Home","title":"Home","text":"Setting up the aforementioned kernel matrix can be done as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nusing IFGF, LinearAlgebra, StaticArrays\nimport IFGF: wavenumber\n\n# random points on a cube\nconst Point3D = SVector{3,Float64}\nm,n = 100_000, 100_000\nX,Y = rand(Point3D,m), rand(Point3D,n)\n\n# define a the kernel matrix\nstruct HelmholtzMatrix <: AbstractMatrix{ComplexF64}\n    X::Vector{Point3D}\n    Y::Vector{Point3D}\n    k::Float64\nend\n\n# indicate that this is an ocillatory kernel with wavenumber `k`\nwavenumber(A::HelmholtzMatrix) = A.k\n\n# functor interface\nfunction (K::HelmholtzMatrix)(x,y)\n    k = wavenumber(K)\n    d = norm(x-y)\n    exp(im*k*d)*inv(4*pi*d)\nend\n\n# abstract matrix interface\nBase.size(::HelmholtzMatrix) = length(X), length(Y)\nBase.getindex(A::HelmholtzMatrix,i::Int,j::Int) = A(A.X[i],A.Y[j])\n\n# create the abstract matrix\nk = 8π   \nA = HelmholtzMatrix(X,Y,k)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that A is a lazy 100000 times 100000 matrix which computes its entries on demand; as such, it has a light memory footprint. Trying to instantiate the underlying Matrix{ComplexF64} would most likely result in you running out of memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To build an approximation of A using the IFGFOp, you may use the high-level constructor assemble_ifgf as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"L = assemble_ifgf(A,X,Y; tol = 1e-4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check the documentation of assemble_ifgf for more information on the available options. One important point to keep in mind is that heuristics are used to determine the optimal number of interpolation points given a tolerance tol; if you want to control the number of interpolation points manually, you may pass a p argument to the assemble_ifgf constructor instead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Info\nTo approximate oscillatory kernels, the IFGF algorithm adapts to the acoustic size of each of the cells in the source tree in order to keep the interpolation error constant across all levels of the tree. In practice, this means that memory and runtime will depend on both the total number of points n and on the wavenumber k, with smaller k being \"easier\" to approximate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can use L in lieu of A to approximate the matrix vector product, as illustrated below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x     = randn(ComplexF64,n)\ny     = L*x","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that L, while not as compact as A, still has a relatively light memory footprint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"gb = Base.summarysize(L) / 1e9\nprint(\"Size of L: $gb gigabytes\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The quality of the approximation may be verified by computing the exact value at a few randomly selected set of indices:","category":"page"},{"location":"","page":"Home","title":"Home","text":"I     = rand(1:m,100)\nexact = [sum(A[i,j]*x[j] for j in 1:n) for i in I] # matrix-vector product\ner    = norm(y[I]-exact) / norm(exact) # relative error\nprint(\"approximate relative error: $er\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Kernel optimizations\nTo keep things simple in this example, we neglected some important optimizations that can be performed when defining your own kernel. In particular, you can overload some default (generic) methods for your own kernel to provide e.g. a vectorized evaluation using SIMD instructions. We also avoided the possible issue of kernel blowing up at boldsymbolx = boldsymboly.","category":"page"},{"location":"#custom-kernel-section","page":"Home","title":"Custom kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When defining your own kernels, there is one required as well as some optional methods to overload in order to provide kernel-specific information to the constructor. The table below summarizes the interface methods, where Y is a SourceTree object, x is an SVector representing a point, and K is your custom kernel:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method's name Required Brief description\nwavenumber(K) Yes Return the wavenumber of your kernel\nreturn_type(K) No Type of element returned by K(x,y)\ncentered_factor(K,x,Y) No A representative value of K(x,y) for y ∈ Y\ninv_centered_factor(K,x,Y) No A representative value of inv(K(x,y)) for y ∈ Y\ntransfer_factor(K,x,Y) No Transfer function given by inv_centered_factor(K,x,parent(Y))*centered_factor(K,x,Y)\nnear_interaction!(C,K,X,Y,σ,I,J) No Compute C[i] <- C[i] + ∑ⱼ K(X[i],Y[j])*σ[j] for i ∈ I, j ∈ J","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because the IFGF algorithms must adapt its interpolation scheme depending on the frequency of oscillations to control the interpolation error, you must extend the IFGF.wavenumber method. If the kernel is not oscillatory (e.g. exponential kernel, Newtonian potential), simply return 0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The centered_factor, inv_centered_factor, and transfer_factor have reasonable defaults, and typically are overloaded only for performance reasons (e.g. if some analytic simplifications are available).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the near_interaction method is called at the leaves of the source tree to compute the near interactions. Extending this function to make use of e.g. SIMD instructions can significantly speed up some parts of the code.","category":"page"},{"location":"#Advanced-usage","page":"Home","title":"Advanced usage","text":"","category":"section"}]
}
